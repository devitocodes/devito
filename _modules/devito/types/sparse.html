<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>devito.types.sparse &mdash; Devito v4.6.2</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="shortcut icon" href="../../../_static/devito_logo.png"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link href="../../../_static/devito_style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> Devito v4.6.2
            <img src="../../../_static/devito_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../download.html">Download</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/devitocodes/devito/tree/master/examples">Tutorials</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/devitocodes/devito/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userapi.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Devito v4.6.2</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>devito.types.sparse</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for devito.types.sparse</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>

<span class="kn">import</span> <span class="nn">sympy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">cached_property</span> <span class="kn">import</span> <span class="n">cached_property</span>

<span class="kn">from</span> <span class="nn">devito.finite_differences</span> <span class="kn">import</span> <span class="n">generate_fd_shortcuts</span>
<span class="kn">from</span> <span class="nn">devito.mpi</span> <span class="kn">import</span> <span class="n">MPI</span><span class="p">,</span> <span class="n">SparseDistributor</span>
<span class="kn">from</span> <span class="nn">devito.operations</span> <span class="kn">import</span> <span class="n">LinearInterpolator</span><span class="p">,</span> <span class="n">PrecomputedInterpolator</span>
<span class="kn">from</span> <span class="nn">devito.symbolics</span> <span class="kn">import</span> <span class="p">(</span><span class="n">INT</span><span class="p">,</span> <span class="n">FLOOR</span><span class="p">,</span> <span class="n">cast_mapper</span><span class="p">,</span> <span class="n">indexify</span><span class="p">,</span>
                              <span class="n">retrieve_function_carriers</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">devito.tools</span> <span class="kn">import</span> <span class="p">(</span><span class="n">ReducerMap</span><span class="p">,</span> <span class="n">as_tuple</span><span class="p">,</span> <span class="n">flatten</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">filter_ordered</span><span class="p">,</span>
                          <span class="n">memoized_meth</span><span class="p">,</span> <span class="n">is_integer</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">devito.types.dense</span> <span class="kn">import</span> <span class="n">DiscreteFunction</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">SubFunction</span>
<span class="kn">from</span> <span class="nn">devito.types.dimension</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Dimension</span><span class="p">,</span> <span class="n">ConditionalDimension</span><span class="p">,</span> <span class="n">DefaultDimension</span><span class="p">,</span>
                                    <span class="n">DynamicDimension</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">devito.types.basic</span> <span class="kn">import</span> <span class="n">Symbol</span>
<span class="kn">from</span> <span class="nn">devito.types.equation</span> <span class="kn">import</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Inc</span>
<span class="kn">from</span> <span class="nn">devito.types.utils</span> <span class="kn">import</span> <span class="n">IgnoreDimSort</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;SparseFunction&#39;</span><span class="p">,</span> <span class="s1">&#39;SparseTimeFunction&#39;</span><span class="p">,</span> <span class="s1">&#39;PrecomputedSparseFunction&#39;</span><span class="p">,</span>
           <span class="s1">&#39;PrecomputedSparseTimeFunction&#39;</span><span class="p">,</span> <span class="s1">&#39;MatrixSparseTimeFunction&#39;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">AbstractSparseFunction</span><span class="p">(</span><span class="n">DiscreteFunction</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An abstract class to define behaviours common to all sparse functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_sparse_position</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="sd">&quot;&quot;&quot;Position of sparse index among the function indices.&quot;&quot;&quot;</span>

    <span class="n">_radius</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="sd">&quot;&quot;&quot;The radius of the stencil operators provided by the SparseFunction.&quot;&quot;&quot;</span>

    <span class="n">_sub_functions</span> <span class="o">=</span> <span class="p">()</span>
    <span class="sd">&quot;&quot;&quot;SubFunctions encapsulated within this AbstractSparseFunction.&quot;&quot;&quot;</span>

    <span class="n">__rkwargs__</span> <span class="o">=</span> <span class="n">DiscreteFunction</span><span class="o">.</span><span class="n">__rkwargs__</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;npoint&#39;</span><span class="p">,</span> <span class="s1">&#39;space_order&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AbstractSparseFunction</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init_finalize__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_npoint</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;npoint&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_space_order</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;space_order&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Dynamically add derivative short-cuts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__fd_setup__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__fd_setup__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dynamically add derivative short-cuts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">generate_fd_shortcuts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">space_order</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__indices_setup__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="n">as_tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dimensions</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dimension</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;p_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]),)</span>
        <span class="k">return</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">dimensions</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__shape_setup__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;grid&#39;</span><span class="p">)</span>
        <span class="c1"># A Grid must have been provided</span>
        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Need `grid` argument&#39;</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)</span>
        <span class="n">npoint</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;npoint&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">glb_npoint</span> <span class="o">=</span> <span class="n">SparseDistributor</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">npoint</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">distributor</span><span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">glb_npoint</span><span class="p">[</span><span class="n">grid</span><span class="o">.</span><span class="n">distributor</span><span class="o">.</span><span class="n">myrank</span><span class="p">],)</span>
        <span class="k">return</span> <span class="n">shape</span>

    <span class="k">def</span> <span class="nf">_halo_exchange</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># no-op for SparseFunctions</span>
        <span class="k">return</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">npoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparse_position</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">space_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The space order.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_space_order</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_sparse_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparse_position</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gridpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *reference* grid point corresponding to each sparse point.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When using MPI, this property refers to the *physically* owned</span>
<span class="sd">        sparse points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implement an interpolation operation from the grid onto the given sparse points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">inject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implement an injection operation from a sparse point onto the grid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_point_support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_radius</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                                      <span class="n">repeat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dim</span><span class="p">)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The grid points surrounding each sparse point within the radius of self&#39;s</span>
<span class="sd">        injection/interpolation operators.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="n">minmax</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">max_shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">arr</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">minmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridpoints</span> <span class="o">+</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_support</span><span class="p">],</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_dist_datamap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mapper ``M : MPI rank -&gt; required sparse data``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distributor</span><span class="o">.</span><span class="n">glb_to_rank</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_support</span><span class="p">)</span> <span class="ow">or</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">_dist_scatter_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dmap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A mask to index into ``self.data``, which creates a new data array that</span>
<span class="sd">        logically contains N consecutive groups of sparse data values, where N</span>
<span class="sd">        is the number of MPI ranks. The i-th group contains the sparse data</span>
<span class="sd">        values accessible by the i-th MPI rank.  Thus, sparse data values along</span>
<span class="sd">        the boundary of two or more MPI ranks are duplicated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dmap</span> <span class="o">=</span> <span class="n">dmap</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_datamap</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">dmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dmap</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>
        <span class="n">ret</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparse_position</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_dist_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dmap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A 2-tuple of comm-sized iterables, which tells how many sparse points</span>
<span class="sd">        is this MPI rank expected to send/receive to/from each other MPI rank.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dmap</span> <span class="o">=</span> <span class="n">dmap</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_datamap</span>
        <span class="n">comm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distributor</span><span class="o">.</span><span class="n">comm</span>

        <span class="n">ssparse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dmap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">[]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">rsparse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">comm</span><span class="o">.</span><span class="n">Alltoall</span><span class="p">(</span><span class="n">ssparse</span><span class="p">,</span> <span class="n">rsparse</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ssparse</span><span class="p">,</span> <span class="n">rsparse</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_dist_reorder_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An ordering mask that puts ``self._sparse_position`` at the front.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparse_position</span><span class="p">,)</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_dim</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_dist_alltoall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dmap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The metadata necessary to perform an ``MPI_Alltoallv`` distributing the</span>
<span class="sd">        sparse data values across the MPI ranks needing them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ssparse</span><span class="p">,</span> <span class="n">rsparse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_count</span><span class="p">(</span><span class="n">dmap</span><span class="o">=</span><span class="n">dmap</span><span class="p">)</span>

        <span class="c1"># Per-rank shape of send/recv data</span>
        <span class="n">sshape</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">rshape</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ssparse</span><span class="p">,</span> <span class="n">rsparse</span><span class="p">):</span>
            <span class="n">handle</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">handle</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparse_position</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
            <span class="n">sshape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>

            <span class="n">handle</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">handle</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparse_position</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
            <span class="n">rshape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>

        <span class="c1"># Per-rank count of send/recv data</span>
        <span class="n">scount</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sshape</span><span class="p">)</span>
        <span class="n">rcount</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rshape</span><span class="p">)</span>

        <span class="c1"># Per-rank displacement of send/recv data (it&#39;s actually all contiguous,</span>
        <span class="c1"># but the Alltoallv needs this information anyway)</span>
        <span class="n">sdisp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">scount</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">rdisp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">rcount</span><span class="p">))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

        <span class="c1"># Total shape of send/recv data</span>
        <span class="n">sshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">sshape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparse_position</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ssparse</span><span class="p">)</span>
        <span class="n">rshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">rshape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparse_position</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">rsparse</span><span class="p">)</span>

        <span class="c1"># May have to swap axes, as `MPI_Alltoallv` expects contiguous data, and</span>
        <span class="c1"># the sparse dimension may not be the outermost</span>
        <span class="n">sshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sshape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_reorder_mask</span><span class="p">)</span>
        <span class="n">rshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rshape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_reorder_mask</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sshape</span><span class="p">,</span> <span class="n">scount</span><span class="p">,</span> <span class="n">sdisp</span><span class="p">,</span> <span class="n">rshape</span><span class="p">,</span> <span class="n">rcount</span><span class="p">,</span> <span class="n">rdisp</span>

    <span class="k">def</span> <span class="nf">_dist_subfunc_alltoall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dmap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The metadata necessary to perform an ``MPI_Alltoallv`` distributing</span>
<span class="sd">        self&#39;s SubFunction values across the MPI ranks needing them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_dist_scatter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A ``numpy.ndarray`` containing up-to-date data values belonging</span>
<span class="sd">        to the calling MPI rank. A data value belongs to a given MPI rank R</span>
<span class="sd">        if its coordinates fall within R&#39;s local domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_arg_defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">alias</span> <span class="ow">or</span> <span class="bp">self</span>
        <span class="n">mapper</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="p">:</span> <span class="n">key</span><span class="p">}</span>
        <span class="n">mapper</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sub_functions</span><span class="p">})</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">ReducerMap</span><span class="p">()</span>

        <span class="c1"># Add in the sparse data (as well as any SubFunction data) belonging to</span>
        <span class="c1"># self&#39;s local domain only</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_scatter</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">args</span><span class="p">[</span><span class="n">mapper</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mapper</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">_arg_defaults</span><span class="p">(</span><span class="n">_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">s</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">_eval_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_arg_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Add value override for own data if it is provided, otherwise</span>
        <span class="c1"># use defaults</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">AbstractSparseFunction</span><span class="p">):</span>
                <span class="c1"># Set new values and re-derive defaults</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">_arg_defaults</span><span class="p">(</span><span class="n">alias</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We&#39;ve been provided a pure-data replacement (array)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_scatter</span><span class="p">(</span><span class="n">new</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">values</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                        <span class="n">size</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">_size_nodomain</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">values</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">_arg_defaults</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arg_defaults</span><span class="p">(</span><span class="n">alias</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">reduce_all</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">values</span>

    <span class="k">def</span> <span class="nf">_arg_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataobj</span><span class="p">,</span> <span class="n">coordsobj</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">alias</span> <span class="k">if</span> <span class="n">alias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AbstractSparseFunction</span><span class="p">):</span>
            <span class="c1"># Gather into `self.data`</span>
            <span class="c1"># Coords may be None if the coordinates are not used in the Operator</span>
            <span class="k">if</span> <span class="n">coordsobj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">coordsobj</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">coordsobj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">_C_as_ndarray</span><span class="p">(</span><span class="n">coordsobj</span><span class="p">)</span>
            <span class="n">key</span><span class="o">.</span><span class="n">_dist_gather</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_C_as_ndarray</span><span class="p">(</span><span class="n">dataobj</span><span class="p">),</span> <span class="n">coordsobj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distributor</span><span class="o">.</span><span class="n">nprocs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Don&#39;t know how to gather data from an &quot;</span>
                                      <span class="s2">&quot;object of type `</span><span class="si">%s</span><span class="s2">`&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">AbstractSparseTimeFunction</span><span class="p">(</span><span class="n">AbstractSparseFunction</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An abstract class to define behaviours common to all sparse time-varying functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_time_position</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="sd">&quot;&quot;&quot;Position of time index among the function indices.&quot;&quot;&quot;</span>

    <span class="n">__rkwargs__</span> <span class="o">=</span> <span class="n">AbstractSparseFunction</span><span class="o">.</span><span class="n">__rkwargs__</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;nt&#39;</span><span class="p">,</span> <span class="s1">&#39;time_order&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_position</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_order</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;time_order&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_order</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`time_order` must be int&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">AbstractSparseTimeFunction</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init_finalize__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__fd_setup__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dynamically add derivative short-cuts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">generate_fd_shortcuts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">space_order</span><span class="p">,</span>
                                     <span class="n">to</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_order</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The time dimension.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_dim</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__indices_setup__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="n">as_tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dimensions</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time_dim</span><span class="p">,</span>
                          <span class="n">Dimension</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;p_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">dimensions</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__shape_setup__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nt&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Need `nt` int argument&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`nt` must be &gt; 0&#39;</span><span class="p">)</span>

            <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">AbstractSparseFunction</span><span class="o">.</span><span class="n">__shape_setup__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
            <span class="n">shape</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_time_position</span><span class="p">,</span> <span class="n">nt</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_position</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">time_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The time order.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_order</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_time_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape_allocated</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_position</span><span class="p">]</span>


<div class="viewcode-block" id="SparseFunction"><a class="viewcode-back" href="../../../sparsefunction.html#devito.types.SparseFunction">[docs]</a><span class="k">class</span> <span class="nc">SparseFunction</span><span class="p">(</span><span class="n">AbstractSparseFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tensor symbol representing a sparse array in symbolic equations.</span>

<span class="sd">    A SparseFunction carries multi-dimensional data that are not aligned with</span>
<span class="sd">    the computational grid. As such, each data value is associated some coordinates.</span>
<span class="sd">    A SparseFunction provides symbolic interpolation routines to convert between</span>
<span class="sd">    Functions and sparse data points. These are based upon standard [bi,tri]linear</span>
<span class="sd">    interpolation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of the symbol.</span>
<span class="sd">    npoint : int</span>
<span class="sd">        Number of sparse points.</span>
<span class="sd">    grid : Grid</span>
<span class="sd">        The computational domain from which the sparse points are sampled.</span>
<span class="sd">    coordinates : np.ndarray, optional</span>
<span class="sd">        The coordinates of each sparse point.</span>
<span class="sd">    space_order : int, optional</span>
<span class="sd">        Discretisation order for space derivatives. Defaults to 0.</span>
<span class="sd">    shape : tuple of ints, optional</span>
<span class="sd">        Shape of the object. Defaults to ``(npoint,)``.</span>
<span class="sd">    dimensions : tuple of Dimension, optional</span>
<span class="sd">        Dimensions associated with the object. Only necessary if the SparseFunction</span>
<span class="sd">        defines a multi-dimensional tensor.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Any object that can be interpreted as a numpy data type. Defaults</span>
<span class="sd">        to ``np.float32``.</span>
<span class="sd">    initializer : callable or any object exposing the buffer interface, optional</span>
<span class="sd">        Data initializer. If a callable is provided, data is allocated lazily.</span>
<span class="sd">    allocator : MemoryAllocator, optional</span>
<span class="sd">        Controller for memory allocation. To be used, for example, when one wants</span>
<span class="sd">        to take advantage of the memory hierarchy in a NUMA architecture. Refer to</span>
<span class="sd">        `default_allocator.__doc__` for more information.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Creation</span>

<span class="sd">    &gt;&gt;&gt; from devito import Grid, SparseFunction</span>
<span class="sd">    &gt;&gt;&gt; grid = Grid(shape=(4, 4))</span>
<span class="sd">    &gt;&gt;&gt; sf = SparseFunction(name=&#39;sf&#39;, grid=grid, npoint=2)</span>
<span class="sd">    &gt;&gt;&gt; sf</span>
<span class="sd">    sf(p_sf)</span>

<span class="sd">    Inspection</span>

<span class="sd">    &gt;&gt;&gt; sf.data</span>
<span class="sd">    Data([0., 0.], dtype=float32)</span>
<span class="sd">    &gt;&gt;&gt; sf.coordinates</span>
<span class="sd">    sf_coords(p_sf, d)</span>
<span class="sd">    &gt;&gt;&gt; sf.coordinates_data</span>
<span class="sd">    array([[0., 0.],</span>
<span class="sd">           [0., 0.]], dtype=float32)</span>

<span class="sd">    Symbolic interpolation routines</span>

<span class="sd">    &gt;&gt;&gt; from devito import Function</span>
<span class="sd">    &gt;&gt;&gt; f = Function(name=&#39;f&#39;, grid=grid)</span>
<span class="sd">    &gt;&gt;&gt; exprs0 = sf.interpolate(f)</span>
<span class="sd">    &gt;&gt;&gt; exprs1 = sf.inject(f, sf)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The parameters must always be given as keyword arguments, since SymPy</span>
<span class="sd">    uses ``*args`` to (re-)create the dimension arguments of the symbolic object.</span>
<span class="sd">    About SparseFunction and MPI. There is a clear difference between:</span>

<span class="sd">        * Where the sparse points *physically* live, i.e., on which MPI rank. This</span>
<span class="sd">          depends on the user code, particularly on how the data is set up.</span>
<span class="sd">        * and which MPI rank *logically* owns a given sparse point. The logical</span>
<span class="sd">          ownership depends on where the sparse point is located within ``self.grid``.</span>

<span class="sd">    Right before running an Operator (i.e., upon a call to ``op.apply``), a</span>
<span class="sd">    SparseFunction &quot;scatters&quot; its physically owned sparse points so that each</span>
<span class="sd">    MPI rank gets temporary access to all of its logically owned sparse points.</span>
<span class="sd">    A &quot;gather&quot; operation, executed before returning control to user-land,</span>
<span class="sd">    updates the physically owned sparse points in ``self.data`` by collecting</span>
<span class="sd">    the values computed during ``op.apply`` from different MPI ranks.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_SparseFunction</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">_radius</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="sd">&quot;&quot;&quot;The radius of the stencil operators provided by the SparseFunction.&quot;&quot;&quot;</span>

    <span class="n">_sub_functions</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;coordinates&#39;</span><span class="p">,)</span>

    <span class="n">__rkwargs__</span> <span class="o">=</span> <span class="n">AbstractSparseFunction</span><span class="o">.</span><span class="n">__rkwargs__</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;coordinates_data&#39;</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">__init_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SparseFunction</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init_finalize__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span> <span class="o">=</span> <span class="n">LinearInterpolator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># Set up sparse point coordinates</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;coordinates&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;coordinates_data&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coordinates</span> <span class="o">=</span> <span class="n">coordinates</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparse_position</span><span class="p">],</span> <span class="n">Dimension</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">))</span>
            <span class="c1"># Only retain the local data region</span>
            <span class="k">if</span> <span class="n">coordinates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coordinates</span> <span class="o">=</span> <span class="n">SubFunction</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_coords&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                                            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="n">dimensions</span><span class="p">,</span>
                                            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span>
                                            <span class="n">space_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">initializer</span><span class="o">=</span><span class="n">coordinates</span><span class="p">,</span>
                                            <span class="n">distributor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_distributor</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">npoint</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># This is a corner case -- we might get here, for example, when</span>
                <span class="c1"># running with MPI and some processes get 0-size arrays after</span>
                <span class="c1"># domain decomposition. We &quot;touch&quot; the data anyway to avoid the</span>
                <span class="c1"># case ``self._data is None``</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span> <span class="nf">__distributor_setup__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A `SparseDistributor` handles the SparseFunction decomposition based on</span>
<span class="sd">        physical ownership, and allows to convert between global and local indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SparseDistributor</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;npoint&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_dim</span><span class="p">,</span>
                                 <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">distributor</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The SparseFunction coordinates.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coordinates</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coordinates_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_point_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Symbol for coordinate value in each dimension of the point.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;p</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_position_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Symbols map for the position of the sparse points relative to the grid</span>
<span class="sd">        origin.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The expression `(coord - origin)/spacing` could also be computed in the</span>
<span class="sd">        mathematically equivalent expanded form `coord/spacing -</span>
<span class="sd">        origin/spacing`. This particular form is problematic when a sparse</span>
<span class="sd">        point is in close proximity of the grid origin, since due to a larger</span>
<span class="sd">        machine precision error it may cause a +-1 error in the computation of</span>
<span class="sd">        the position. We mitigate this problem by computing the positions</span>
<span class="sd">        individually (hence the need for a position map).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;pos</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="n">c</span> <span class="o">-</span> <span class="n">o</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span>
                                                          <span class="bp">self</span><span class="o">.</span><span class="n">_coordinate_symbols</span><span class="p">,</span>
                                                          <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">origin_symbols</span><span class="p">)])</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_point_increments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Index increments in each dimension for each point symbol.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_coordinate_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Symbol representing the coordinate values in each dimension.&quot;&quot;&quot;</span>
        <span class="n">p_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparse_position</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">indexify</span><span class="p">((</span><span class="n">p_dim</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dim</span><span class="p">)])</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_coordinate_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Symbol for each grid index according to the coordinates.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">INT</span><span class="p">(</span><span class="n">FLOOR</span><span class="p">((</span><span class="n">c</span> <span class="o">-</span> <span class="n">o</span><span class="p">)</span> <span class="o">/</span> <span class="n">i</span><span class="o">.</span><span class="n">spacing</span><span class="p">))</span>
                      <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coordinate_symbols</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">origin_symbols</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dim</span><span class="p">])])</span>

    <span class="k">def</span> <span class="nf">_coordinate_bases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Symbol for the base coordinates of the reference grid point.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">cast_mapper</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">](</span><span class="n">c</span> <span class="o">-</span> <span class="n">o</span> <span class="o">-</span> <span class="n">idx</span> <span class="o">*</span> <span class="n">i</span><span class="o">.</span><span class="n">spacing</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">of</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coordinate_symbols</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">origin_symbols</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">_coordinate_indices</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dim</span><span class="p">],</span>
                                                  <span class="n">field_offset</span><span class="p">)])</span>

    <span class="nd">@memoized_meth</span>
    <span class="k">def</span> <span class="nf">_index_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="c1"># Note about the use of *memoization*</span>
        <span class="c1"># Since this method is called by `_interpolation_indices`, using</span>
        <span class="c1"># memoization avoids a proliferation of symbolically identical</span>
        <span class="c1"># ConditionalDimensions for a given set of indirection indices</span>

        <span class="c1"># List of indirection indices for all adjacent grid points</span>
        <span class="n">index_matrix</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="n">ii</span> <span class="o">+</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">idx</span>
                              <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coordinate_indices</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">inc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_point_increments</span><span class="p">]</span>

        <span class="c1"># A unique symbol for each indirection index</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">filter_ordered</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">index_matrix</span><span class="p">))</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="n">p</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ii_</span><span class="si">%s</span><span class="s1">_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">)))</span>
                              <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">index_matrix</span><span class="p">,</span> <span class="n">points</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gridpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No coordinates attached to this SparseFunction&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_local</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">spacing</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

<div class="viewcode-block" id="SparseFunction.guard"><a class="viewcode-back" href="../../../sparsefunction.html#devito.types.SparseFunction.guard">[docs]</a>    <span class="k">def</span> <span class="nf">guard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate guarded expressions, that is expressions that are evaluated</span>
<span class="sd">        by an Operator only if certain conditions are met.  The introduced</span>
<span class="sd">        condition, here, is that all grid points in the support of a sparse</span>
<span class="sd">        value must fall within the grid domain (i.e., *not* on the halo).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expr : expr-like, optional</span>
<span class="sd">            Input expression, from which the guarded expression is derived.</span>
<span class="sd">            If not specified, defaults to ``self``.</span>
<span class="sd">        offset : int, optional</span>
<span class="sd">            Relax the guard condition by introducing a tolerance offset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_matrix</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>

        <span class="c1"># Guard through ConditionalDimension</span>
        <span class="n">conditions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coordinate_indices</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="n">d</span><span class="o">.</span><span class="n">symbolic_min</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="o">.</span><span class="n">symbolic_max</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">conditions</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="o">*</span><span class="n">conditions</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="n">ConditionalDimension</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparse_dim</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_dim</span><span class="p">,</span>
                                  <span class="n">condition</span><span class="o">=</span><span class="n">condition</span><span class="p">,</span> <span class="n">indirect</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexify</span><span class="p">()</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparse_dim</span><span class="p">:</span> <span class="n">cd</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">functions</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">retrieve_function_carriers</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
                         <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">is_SparseFunction</span><span class="p">}</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">indexify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">f</span><span class="o">.</span><span class="n">_sparse_dim</span><span class="p">:</span> <span class="n">cd</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">})</span>

        <span class="c1"># Temporaries for the position</span>
        <span class="n">temps</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">implicit_dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_position_map</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="c1"># Temporaries for the indirection dimensions</span>
        <span class="n">temps</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">Eq</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_position_map</span><span class="p">),</span>
                         <span class="n">implicit_dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">points</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">conditions</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">temps</span></div>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_decomposition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mapper</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparse_dim</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distributor</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparse_dim</span><span class="p">]}</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mapper</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_dist_subfunc_alltoall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dmap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">dmap</span> <span class="o">=</span> <span class="n">dmap</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_datamap</span>
        <span class="n">ssparse</span><span class="p">,</span> <span class="n">rsparse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_count</span><span class="p">(</span><span class="n">dmap</span><span class="o">=</span><span class="n">dmap</span><span class="p">)</span>

        <span class="c1"># Per-rank shape of send/recv `coordinates`</span>
        <span class="n">sshape</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ssparse</span><span class="p">]</span>
        <span class="n">rshape</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rsparse</span><span class="p">]</span>

        <span class="c1"># Per-rank count of send/recv `coordinates`</span>
        <span class="n">scount</span> <span class="o">=</span> <span class="p">[</span><span class="n">prod</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sshape</span><span class="p">]</span>
        <span class="n">rcount</span> <span class="o">=</span> <span class="p">[</span><span class="n">prod</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rshape</span><span class="p">]</span>

        <span class="c1"># Per-rank displacement of send/recv `coordinates` (it&#39;s actually all</span>
        <span class="c1"># contiguous, but the Alltoallv needs this information anyway)</span>
        <span class="n">sdisp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">scount</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">rdisp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">rcount</span><span class="p">))[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

        <span class="c1"># Total shape of send/recv `coordinates`</span>
        <span class="n">sshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">sshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ssparse</span><span class="p">)</span>
        <span class="n">rshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">rshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">rsparse</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sshape</span><span class="p">,</span> <span class="n">scount</span><span class="p">,</span> <span class="n">sdisp</span><span class="p">,</span> <span class="n">rshape</span><span class="p">,</span> <span class="n">rcount</span><span class="p">,</span> <span class="n">rdisp</span>

    <span class="k">def</span> <span class="nf">_dist_scatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_local</span>
        <span class="n">distributor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distributor</span>

        <span class="c1"># If not using MPI, don&#39;t waste time</span>
        <span class="k">if</span> <span class="n">distributor</span><span class="o">.</span><span class="n">nprocs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">data</span><span class="p">}</span>

        <span class="n">comm</span> <span class="o">=</span> <span class="n">distributor</span><span class="o">.</span><span class="n">comm</span>
        <span class="n">mpitype</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">_typedict</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">char</span><span class="p">]</span>

        <span class="c1"># Compute dist map only once</span>
        <span class="n">dmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_datamap</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_scatter_mask</span><span class="p">(</span><span class="n">dmap</span><span class="o">=</span><span class="n">dmap</span><span class="p">)</span>

        <span class="c1"># Pack sparse data values so that they can be sent out via an Alltoallv</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_reorder_mask</span><span class="p">))</span>

        <span class="c1"># Send out the sparse point values</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">scount</span><span class="p">,</span> <span class="n">sdisp</span><span class="p">,</span> <span class="n">rshape</span><span class="p">,</span> <span class="n">rcount</span><span class="p">,</span> <span class="n">rdisp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_alltoall</span><span class="p">(</span><span class="n">dmap</span><span class="o">=</span><span class="n">dmap</span><span class="p">)</span>
        <span class="n">scattered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">rshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">comm</span><span class="o">.</span><span class="n">Alltoallv</span><span class="p">([</span><span class="n">data</span><span class="p">,</span> <span class="n">scount</span><span class="p">,</span> <span class="n">sdisp</span><span class="p">,</span> <span class="n">mpitype</span><span class="p">],</span>
                       <span class="p">[</span><span class="n">scattered</span><span class="p">,</span> <span class="n">rcount</span><span class="p">,</span> <span class="n">rdisp</span><span class="p">,</span> <span class="n">mpitype</span><span class="p">])</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">scattered</span>

        <span class="c1"># Unpack data values so that they follow the expected storage layout</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_reorder_mask</span><span class="p">))</span>

        <span class="c1"># Pack (reordered) coordinates so that they can be sent out via an Alltoallv</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_local</span><span class="p">[</span><span class="n">mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparse_position</span><span class="p">]]</span>

        <span class="c1"># Send out the sparse point coordinates</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">scount</span><span class="p">,</span> <span class="n">sdisp</span><span class="p">,</span> <span class="n">rshape</span><span class="p">,</span> <span class="n">rcount</span><span class="p">,</span> <span class="n">rdisp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_subfunc_alltoall</span><span class="p">(</span><span class="n">dmap</span><span class="o">=</span><span class="n">dmap</span><span class="p">)</span>
        <span class="n">scattered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">rshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">comm</span><span class="o">.</span><span class="n">Alltoallv</span><span class="p">([</span><span class="n">coords</span><span class="p">,</span> <span class="n">scount</span><span class="p">,</span> <span class="n">sdisp</span><span class="p">,</span> <span class="n">mpitype</span><span class="p">],</span>
                       <span class="p">[</span><span class="n">scattered</span><span class="p">,</span> <span class="n">rcount</span><span class="p">,</span> <span class="n">rdisp</span><span class="p">,</span> <span class="n">mpitype</span><span class="p">])</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">scattered</span>

        <span class="c1"># Translate global coordinates into local coordinates</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">origin_offset</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="p">:</span> <span class="n">coords</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">_dist_gather</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="n">distributor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distributor</span>

        <span class="c1"># If not using MPI, don&#39;t waste time</span>
        <span class="k">if</span> <span class="n">distributor</span><span class="o">.</span><span class="n">nprocs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">comm</span> <span class="o">=</span> <span class="n">distributor</span><span class="o">.</span><span class="n">comm</span>

        <span class="c1"># Compute dist map only once</span>
        <span class="n">dmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_datamap</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_scatter_mask</span><span class="p">(</span><span class="n">dmap</span><span class="o">=</span><span class="n">dmap</span><span class="p">)</span>

        <span class="c1"># Pack sparse data values so that they can be sent out via an Alltoallv</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_reorder_mask</span><span class="p">))</span>
        <span class="c1"># Send back the sparse point values</span>
        <span class="n">sshape</span><span class="p">,</span> <span class="n">scount</span><span class="p">,</span> <span class="n">sdisp</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">rcount</span><span class="p">,</span> <span class="n">rdisp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_alltoall</span><span class="p">(</span><span class="n">dmap</span><span class="o">=</span><span class="n">dmap</span><span class="p">)</span>
        <span class="n">gathered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">sshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">mpitype</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">_typedict</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">char</span><span class="p">]</span>
        <span class="n">comm</span><span class="o">.</span><span class="n">Alltoallv</span><span class="p">([</span><span class="n">data</span><span class="p">,</span> <span class="n">rcount</span><span class="p">,</span> <span class="n">rdisp</span><span class="p">,</span> <span class="n">mpitype</span><span class="p">],</span>
                       <span class="p">[</span><span class="n">gathered</span><span class="p">,</span> <span class="n">scount</span><span class="p">,</span> <span class="n">sdisp</span><span class="p">,</span> <span class="n">mpitype</span><span class="p">])</span>
        <span class="c1"># Unpack data values so that they follow the expected storage layout</span>
        <span class="n">gathered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">gathered</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dist_reorder_mask</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">gathered</span><span class="p">[:]</span>

        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Pack (reordered) coordinates so that they can be sent out via an Alltoallv</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">origin_offset</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="c1"># Send out the sparse point coordinates</span>
            <span class="n">sshape</span><span class="p">,</span> <span class="n">scount</span><span class="p">,</span> <span class="n">sdisp</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">rcount</span><span class="p">,</span> <span class="n">rdisp</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_dist_subfunc_alltoall</span><span class="p">(</span><span class="n">dmap</span><span class="o">=</span><span class="n">dmap</span><span class="p">)</span>
            <span class="n">gathered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">sshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">mpitype</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">_typedict</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">char</span><span class="p">]</span>
            <span class="n">comm</span><span class="o">.</span><span class="n">Alltoallv</span><span class="p">([</span><span class="n">coords</span><span class="p">,</span> <span class="n">rcount</span><span class="p">,</span> <span class="n">rdisp</span><span class="p">,</span> <span class="n">mpitype</span><span class="p">],</span>
                           <span class="p">[</span><span class="n">gathered</span><span class="p">,</span> <span class="n">scount</span><span class="p">,</span> <span class="n">sdisp</span><span class="p">,</span> <span class="n">mpitype</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coordinates</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_local</span><span class="p">[</span><span class="n">mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparse_position</span><span class="p">]]</span> <span class="o">=</span> <span class="n">gathered</span><span class="p">[:]</span></div>

        <span class="c1"># Note: this method &quot;mirrors&quot; `_dist_scatter`: a sparse point that is sent</span>
        <span class="c1"># in `_dist_scatter` is here received; a sparse point that is received in</span>
        <span class="c1"># `_dist_scatter` is here sent.</span>


<div class="viewcode-block" id="SparseTimeFunction"><a class="viewcode-back" href="../../../sparsetimefunction.html#devito.types.SparseTimeFunction">[docs]</a><span class="k">class</span> <span class="nc">SparseTimeFunction</span><span class="p">(</span><span class="n">AbstractSparseTimeFunction</span><span class="p">,</span> <span class="n">SparseFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tensor symbol representing a space- and time-varying sparse array in symbolic</span>
<span class="sd">    equations.</span>

<span class="sd">    Like SparseFunction, SparseTimeFunction carries multi-dimensional data that</span>
<span class="sd">    are not aligned with the computational grid. As such, each data value is</span>
<span class="sd">    associated some coordinates.</span>
<span class="sd">    A SparseTimeFunction provides symbolic interpolation routines to convert</span>
<span class="sd">    between TimeFunctions and sparse data points. These are based upon standard</span>
<span class="sd">    [bi,tri]linear interpolation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of the symbol.</span>
<span class="sd">    npoint : int</span>
<span class="sd">        Number of sparse points.</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of timesteps along the time dimension.</span>
<span class="sd">    grid : Grid</span>
<span class="sd">        The computational domain from which the sparse points are sampled.</span>
<span class="sd">    coordinates : np.ndarray, optional</span>
<span class="sd">        The coordinates of each sparse point.</span>
<span class="sd">    space_order : int, optional</span>
<span class="sd">        Discretisation order for space derivatives. Defaults to 0.</span>
<span class="sd">    time_order : int, optional</span>
<span class="sd">        Discretisation order for time derivatives. Defaults to 1.</span>
<span class="sd">    shape : tuple of ints, optional</span>
<span class="sd">        Shape of the object. Defaults to ``(nt, npoint)``.</span>
<span class="sd">    dimensions : tuple of Dimension, optional</span>
<span class="sd">        Dimensions associated with the object. Only necessary if the SparseFunction</span>
<span class="sd">        defines a multi-dimensional tensor.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Any object that can be interpreted as a numpy data type. Defaults</span>
<span class="sd">        to ``np.float32``.</span>
<span class="sd">    initializer : callable or any object exposing the buffer interface, optional</span>
<span class="sd">        Data initializer. If a callable is provided, data is allocated lazily.</span>
<span class="sd">    allocator : MemoryAllocator, optional</span>
<span class="sd">        Controller for memory allocation. To be used, for example, when one wants</span>
<span class="sd">        to take advantage of the memory hierarchy in a NUMA architecture. Refer to</span>
<span class="sd">        `default_allocator.__doc__` for more information.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Creation</span>

<span class="sd">    &gt;&gt;&gt; from devito import Grid, SparseTimeFunction</span>
<span class="sd">    &gt;&gt;&gt; grid = Grid(shape=(4, 4))</span>
<span class="sd">    &gt;&gt;&gt; sf = SparseTimeFunction(name=&#39;sf&#39;, grid=grid, npoint=2, nt=3)</span>
<span class="sd">    &gt;&gt;&gt; sf</span>
<span class="sd">    sf(time, p_sf)</span>

<span class="sd">    Inspection</span>

<span class="sd">    &gt;&gt;&gt; sf.data</span>
<span class="sd">    Data([[0., 0.],</span>
<span class="sd">          [0., 0.],</span>
<span class="sd">          [0., 0.]], dtype=float32)</span>
<span class="sd">    &gt;&gt;&gt; sf.coordinates</span>
<span class="sd">    sf_coords(p_sf, d)</span>
<span class="sd">    &gt;&gt;&gt; sf.coordinates_data</span>
<span class="sd">    array([[0., 0.],</span>
<span class="sd">           [0., 0.]], dtype=float32)</span>

<span class="sd">    Symbolic interpolation routines</span>

<span class="sd">    &gt;&gt;&gt; from devito import TimeFunction</span>
<span class="sd">    &gt;&gt;&gt; f = TimeFunction(name=&#39;f&#39;, grid=grid)</span>
<span class="sd">    &gt;&gt;&gt; exprs0 = sf.interpolate(f)</span>
<span class="sd">    &gt;&gt;&gt; exprs1 = sf.inject(f, sf)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The parameters must always be given as keyword arguments, since SymPy</span>
<span class="sd">    uses ``*args`` to (re-)create the dimension arguments of the symbolic object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_SparseTimeFunction</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">__rkwargs__</span> <span class="o">=</span> <span class="p">(</span><span class="n">AbstractSparseTimeFunction</span><span class="o">.</span><span class="n">__rkwargs__</span> <span class="o">+</span>
                   <span class="n">SparseFunction</span><span class="o">.</span><span class="n">__rkwargs__</span><span class="p">)</span>

<div class="viewcode-block" id="SparseTimeFunction.interpolate"><a class="viewcode-back" href="../../../sparsetimefunction.html#devito.types.SparseTimeFunction.interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">u_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">increment</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate equations interpolating an arbitrary expression into ``self``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expr : expr-like</span>
<span class="sd">            Input expression to interpolate.</span>
<span class="sd">        offset : int, optional</span>
<span class="sd">            Additional offset from the boundary.</span>
<span class="sd">        u_t : expr-like, optional</span>
<span class="sd">            Time index at which the interpolation is performed.</span>
<span class="sd">        p_t : expr-like, optional</span>
<span class="sd">            Time index at which the result of the interpolation is stored.</span>
<span class="sd">        increment: bool, optional</span>
<span class="sd">            If True, generate increments (Inc) rather than assignments (Eq).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Apply optional time symbol substitutions to expr</span>
        <span class="n">subs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">u_t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">time_dim</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">stepping_dim</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">time</span><span class="p">:</span> <span class="n">u_t</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">u_t</span><span class="p">})</span>

        <span class="k">if</span> <span class="n">p_t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subs</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">time_dim</span><span class="p">:</span> <span class="n">p_t</span><span class="p">}</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">SparseTimeFunction</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
                                                           <span class="n">increment</span><span class="o">=</span><span class="n">increment</span><span class="p">,</span>
                                                           <span class="n">self_subs</span><span class="o">=</span><span class="n">subs</span><span class="p">)</span></div>

<div class="viewcode-block" id="SparseTimeFunction.inject"><a class="viewcode-back" href="../../../sparsetimefunction.html#devito.types.SparseTimeFunction.inject">[docs]</a>    <span class="k">def</span> <span class="nf">inject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">u_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">implicit_dims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate equations injecting an arbitrary expression into a field.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        field : Function</span>
<span class="sd">            Input field into which the injection is performed.</span>
<span class="sd">        expr : expr-like</span>
<span class="sd">            Injected expression.</span>
<span class="sd">        offset : int, optional</span>
<span class="sd">            Additional offset from the boundary.</span>
<span class="sd">        u_t : expr-like, optional</span>
<span class="sd">            Time index at which the interpolation is performed.</span>
<span class="sd">        p_t : expr-like, optional</span>
<span class="sd">            Time index at which the result of the interpolation is stored.</span>
<span class="sd">        implicit_dims : Dimension or list of Dimension, optional</span>
<span class="sd">            An ordered list of Dimensions that do not explicitly appear in the</span>
<span class="sd">            injection expression, but that should be honored when constructing</span>
<span class="sd">            the operator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Apply optional time symbol substitutions to field and expr</span>
        <span class="k">if</span> <span class="n">u_t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">field</span><span class="o">.</span><span class="n">time_dim</span><span class="p">:</span> <span class="n">u_t</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">p_t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">time_dim</span><span class="p">:</span> <span class="n">p_t</span><span class="p">})</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">implicit_dims</span><span class="o">=</span><span class="n">implicit_dims</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PrecomputedSparseFunction"><a class="viewcode-back" href="../../../precsparsefunction.html#devito.types.PrecomputedSparseFunction">[docs]</a><span class="k">class</span> <span class="nc">PrecomputedSparseFunction</span><span class="p">(</span><span class="n">AbstractSparseFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tensor symbol representing a sparse array in symbolic equations; unlike</span>
<span class="sd">    SparseFunction, PrecomputedSparseFunction uses externally-defined data</span>
<span class="sd">    for interpolation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of the symbol.</span>
<span class="sd">    npoint : int</span>
<span class="sd">        Number of sparse points.</span>
<span class="sd">    grid : Grid</span>
<span class="sd">        The computational domain from which the sparse points are sampled.</span>
<span class="sd">    r : int</span>
<span class="sd">        Number of gridpoints in each dimension to interpolate a single sparse</span>
<span class="sd">        point to. E.g. ``r=2`` for linear interpolation.</span>
<span class="sd">    gridpoints : np.ndarray, optional</span>
<span class="sd">        An array carrying the *reference* grid point corresponding to each sparse point.</span>
<span class="sd">        Of all the gridpoints that one sparse point would be interpolated to, this is the</span>
<span class="sd">        grid point closest to the origin, i.e. the one with the lowest value of each</span>
<span class="sd">        coordinate dimension. Must be a two-dimensional array of shape</span>
<span class="sd">        ``(npoint, grid.ndim)``.</span>
<span class="sd">    interpolation_coeffs : np.ndarray, optional</span>
<span class="sd">        An array containing the coefficient for each of the r^2 (2D) or r^3 (3D)</span>
<span class="sd">        gridpoints that each sparse point will be interpolated to. The coefficient is</span>
<span class="sd">        split across the n dimensions such that the contribution of the point (i, j, k)</span>
<span class="sd">        will be multiplied by ``interpolation_coeffs[..., i]*interpolation_coeffs[...,</span>
<span class="sd">        j]*interpolation_coeffs[...,k]``. So for ``r=6``, we will store 18</span>
<span class="sd">        coefficients per sparse point (instead of potentially 216).</span>
<span class="sd">        Must be a three-dimensional array of shape ``(npoint, grid.ndim, r)``.</span>
<span class="sd">    space_order : int, optional</span>
<span class="sd">        Discretisation order for space derivatives. Defaults to 0.</span>
<span class="sd">    shape : tuple of ints, optional</span>
<span class="sd">        Shape of the object. Defaults to ``(npoint,)``.</span>
<span class="sd">    dimensions : tuple of Dimension, optional</span>
<span class="sd">        Dimensions associated with the object. Only necessary if the SparseFunction</span>
<span class="sd">        defines a multi-dimensional tensor.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Any object that can be interpreted as a numpy data type. Defaults</span>
<span class="sd">        to ``np.float32``.</span>
<span class="sd">    initializer : callable or any object exposing the buffer interface, optional</span>
<span class="sd">        Data initializer. If a callable is provided, data is allocated lazily.</span>
<span class="sd">    allocator : MemoryAllocator, optional</span>
<span class="sd">        Controller for memory allocation. To be used, for example, when one wants</span>
<span class="sd">        to take advantage of the memory hierarchy in a NUMA architecture. Refer to</span>
<span class="sd">        `default_allocator.__doc__` for more information.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The parameters must always be given as keyword arguments, since SymPy</span>
<span class="sd">    uses ``*args`` to (re-)create the dimension arguments of the symbolic object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_PrecomputedSparseFunction</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">_sub_functions</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;gridpoints&#39;</span><span class="p">,</span> <span class="s1">&#39;interpolation_coeffs&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PrecomputedSparseFunction</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init_finalize__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Grid points per sparse point (2 in the case of bilinear and trilinear)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">gridpoints</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;gridpoints&#39;</span><span class="p">)</span>
        <span class="n">interpolation_coeffs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;interpolation_coeffs&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">interpolator</span> <span class="o">=</span> <span class="n">PrecomputedInterpolator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">gridpoints</span><span class="p">,</span>
                                                    <span class="n">interpolation_coeffs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gridpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gridpoints</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">interpolation_coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; The Precomputed interpolation coefficients.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolation_coeffs</span>

    <span class="k">def</span> <span class="nf">_dist_scatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">distributor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distributor</span>

        <span class="c1"># If not using MPI, don&#39;t waste time</span>
        <span class="k">if</span> <span class="n">distributor</span><span class="o">.</span><span class="n">nprocs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="p">:</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridpoints</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridpoints</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_interpolation_coeffs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolation_coeffs</span><span class="o">.</span><span class="n">data</span><span class="p">}</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_dist_gather</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">distributor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distributor</span>

        <span class="c1"># If not using MPI, don&#39;t waste time</span>
        <span class="k">if</span> <span class="n">distributor</span><span class="o">.</span><span class="n">nprocs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_arg_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">distributor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distributor</span>

        <span class="c1"># If not using MPI, don&#39;t waste time</span>
        <span class="k">if</span> <span class="n">distributor</span><span class="o">.</span><span class="n">nprocs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="PrecomputedSparseTimeFunction"><a class="viewcode-back" href="../../../precsparsetimefunction.html#devito.types.PrecomputedSparseTimeFunction">[docs]</a><span class="k">class</span> <span class="nc">PrecomputedSparseTimeFunction</span><span class="p">(</span><span class="n">AbstractSparseTimeFunction</span><span class="p">,</span>
                                    <span class="n">PrecomputedSparseFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tensor symbol representing a space- and time-varying sparse array in symbolic</span>
<span class="sd">    equations; unlike SparseTimeFunction, PrecomputedSparseTimeFunction uses</span>
<span class="sd">    externally-defined data for interpolation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of the symbol.</span>
<span class="sd">    npoint : int</span>
<span class="sd">        Number of sparse points.</span>
<span class="sd">    grid : Grid</span>
<span class="sd">        The computational domain from which the sparse points are sampled.</span>
<span class="sd">    r : int</span>
<span class="sd">        Number of gridpoints in each dimension to interpolate a single sparse</span>
<span class="sd">        point to. E.g. ``r=2`` for linear interpolation.</span>
<span class="sd">    gridpoints : np.ndarray, optional</span>
<span class="sd">        An array carrying the *reference* grid point corresponding to each sparse point.</span>
<span class="sd">        Of all the gridpoints that one sparse point would be interpolated to, this is the</span>
<span class="sd">        grid point closest to the origin, i.e. the one with the lowest value of each</span>
<span class="sd">        coordinate dimension. Must be a two-dimensional array of shape</span>
<span class="sd">        ``(npoint, grid.ndim)``.</span>
<span class="sd">    interpolation_coeffs : np.ndarray, optional</span>
<span class="sd">        An array containing the coefficient for each of the r^2 (2D) or r^3 (3D)</span>
<span class="sd">        gridpoints that each sparse point will be interpolated to. The coefficient is</span>
<span class="sd">        split across the n dimensions such that the contribution of the point (i, j, k)</span>
<span class="sd">        will be multiplied by ``interpolation_coeffs[..., i]*interpolation_coeffs[...,</span>
<span class="sd">        j]*interpolation_coeffs[...,k]``. So for ``r=6``, we will store 18 coefficients</span>
<span class="sd">        per sparse point (instead of potentially 216). Must be a three-dimensional array</span>
<span class="sd">        of shape ``(npoint, grid.ndim, r)``.</span>
<span class="sd">    space_order : int, optional</span>
<span class="sd">        Discretisation order for space derivatives. Defaults to 0.</span>
<span class="sd">    time_order : int, optional</span>
<span class="sd">        Discretisation order for time derivatives. Default to 1.</span>
<span class="sd">    shape : tuple of ints, optional</span>
<span class="sd">        Shape of the object. Defaults to ``(npoint,)``.</span>
<span class="sd">    dimensions : tuple of Dimension, optional</span>
<span class="sd">        Dimensions associated with the object. Only necessary if the SparseFunction</span>
<span class="sd">        defines a multi-dimensional tensor.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Any object that can be interpreted as a numpy data type. Defaults</span>
<span class="sd">        to ``np.float32``.</span>
<span class="sd">    initializer : callable or any object exposing the buffer interface, optional</span>
<span class="sd">        Data initializer. If a callable is provided, data is allocated lazily.</span>
<span class="sd">    allocator : MemoryAllocator, optional</span>
<span class="sd">        Controller for memory allocation. To be used, for example, when one wants</span>
<span class="sd">        to take advantage of the memory hierarchy in a NUMA architecture. Refer to</span>
<span class="sd">        `default_allocator.__doc__` for more information.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The parameters must always be given as keyword arguments, since SymPy</span>
<span class="sd">    uses ``*args`` to (re-)create the dimension arguments of the symbolic object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_PrecomputedSparseTimeFunction</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="PrecomputedSparseTimeFunction.interpolate"><a class="viewcode-back" href="../../../precsparsetimefunction.html#devito.types.PrecomputedSparseTimeFunction.interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">u_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">increment</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate equations interpolating an arbitrary expression into ``self``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expr : expr-like</span>
<span class="sd">            Input expression to interpolate.</span>
<span class="sd">        offset : int, optional</span>
<span class="sd">            Additional offset from the boundary.</span>
<span class="sd">        u_t : expr-like, optional</span>
<span class="sd">            Time index at which the interpolation is performed.</span>
<span class="sd">        p_t : expr-like, optional</span>
<span class="sd">            Time index at which the result of the interpolation is stored.</span>
<span class="sd">        increment: bool, optional</span>
<span class="sd">            If True, generate increments (Inc) rather than assignments (Eq).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">subs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">u_t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">time_dim</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">stepping_dim</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">time</span><span class="p">:</span> <span class="n">u_t</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">u_t</span><span class="p">})</span>

        <span class="k">if</span> <span class="n">p_t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subs</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">time_dim</span><span class="p">:</span> <span class="n">p_t</span><span class="p">}</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">PrecomputedSparseTimeFunction</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">increment</span><span class="o">=</span><span class="n">increment</span><span class="p">,</span> <span class="n">self_subs</span><span class="o">=</span><span class="n">subs</span>
        <span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">MatrixSparseTimeFunction</span><span class="p">(</span><span class="n">AbstractSparseTimeFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A specialised type of SparseTimeFunction where the interpolation is externally</span>
<span class="sd">    defined.  Currently, this means that the (integer) grid points and associated</span>
<span class="sd">    coefficients for each sparse point are explicitly provided as separate</span>
<span class="sd">    SubFunctions.</span>

<span class="sd">    Additionally, this class allows sources and receivers to be constructed</span>
<span class="sd">    from multiple locations, each with their own coefficients.  This is to support</span>
<span class="sd">    injection and sampling of dipole (and more general) sources and receivers,</span>
<span class="sd">    without needing to store multiple versions of the sample data that vary only</span>
<span class="sd">    by a scalar constant.</span>

<span class="sd">    matrix: scipy.sparse matrix</span>
<span class="sd">        A scipy-style sparse matrix with a row for each physical</span>
<span class="sd">        point in the grid, and a column for each index into the</span>
<span class="sd">        data array.</span>

<span class="sd">    r: int or Mapping[Dimension, Optional[int]]</span>
<span class="sd">        The number of gridpoints in each dimension used to inject/interpolate</span>
<span class="sd">        each physical point.  e.g. bi-/tri-linear interplation would use 2 coefficients</span>
<span class="sd">        in each dimension.</span>

<span class="sd">        The Mapping version of this parameter allows a different number of grid points</span>
<span class="sd">        in each dimension. If a Dimension maps to None, this has a special</span>
<span class="sd">        interpretation - sources are not localised to coordinates in that dimension.</span>
<span class="sd">        This is loosely equivalent to specifying r[dim] = dim_size, and with all</span>
<span class="sd">        gridpoint locations along that dimension equal to zero.</span>

<span class="sd">    par_dim: Dimension</span>
<span class="sd">        If set, this is the dimension used to split the sources for parallel</span>
<span class="sd">        injection. The source injection loop becomes a loop over this spatial</span>
<span class="sd">        dimension, and then a loop over sources which touch that spatial</span>
<span class="sd">        dimension coordinate. This defaults to grid.dimensions[0], and if specified</span>
<span class="sd">        must correspond to one of the grid.dimensions.</span>

<span class="sd">    other parameters as per SparseTimeFunction</span>

<span class="sd">    Location/coefficient data:</span>
<span class="sd">        msf.gridpoints.data[iloc, idim]: int</span>
<span class="sd">            integer, position (in global coordinates)</span>
<span class="sd">            of the _minimum_ index that location index</span>
<span class="sd">            `iloc` is interpolated from / injected into, in dimension `idim`</span>
<span class="sd">            where idim is an index into the grid.dimensions</span>

<span class="sd">        msf.interpolation_coefficients: Dict[Dimension, np.ndarray]</span>
<span class="sd">            For each dimension, there is an array of interpolation coefficients</span>
<span class="sd">            for each location `iloc`.</span>

<span class="sd">            This array is of shape (nloc, r), and is also available as</span>
<span class="sd">                msf.coefficients_x.data[iloc, ir]</span>

<span class="sd">            These are the coefficients that are multiplied by sample values</span>
<span class="sd">            at the gridpoints in the range:</span>

<span class="sd">            [msf.gridpoints.data[iloc, idim], msf.gridpoints.data[iloc, idim] + r)</span>

<span class="sd">    NOTE: *** restriction on space order of functions being sampled/injected into</span>

<span class="sd">    The halo of the function being interpolated/injected into</span>
<span class="sd">    must be larger than r, otherwise out of bounds access may result.</span>

<span class="sd">    NOTE: *** explicit scatter/gather semantics</span>

<span class="sd">    Before using this in an Operator, msf.manual_scatter() must be called to</span>
<span class="sd">    distribute the data.  This only needs to be done once for any number of</span>
<span class="sd">    calls to the Operator (e.g. for checkpointing), if the data, gridpoints</span>
<span class="sd">    and coefficients have not changed.</span>

<span class="sd">    This is true whether or not MPI is being used, and independent of</span>
<span class="sd">    the MPI_Size.</span>

<span class="sd">    Likewise, after all time steps have been run, data must be collected</span>
<span class="sd">    from remote ranks using msf.manual_gather() before relying on any of the</span>
<span class="sd">    data from msf.data[:]</span>

<span class="sd">    .. note::</span>

<span class="sd">        The parameters must always be given as keyword arguments, since</span>
<span class="sd">        SymPy uses `*args` to (re-)create the dimension arguments of the</span>
<span class="sd">        symbolic function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_SparseFunction</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">is_SparseTimeFunction</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">_time_position</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="sd">&quot;&quot;&quot;Position of time index among the function indices.&quot;&quot;&quot;</span>

    <span class="c1"># We use DiscreteFunction instead of AbstractSparseTimeFunction</span>
    <span class="c1"># because we want to get rid of &#39;npoint&#39;</span>
    <span class="n">__rkwargs__</span> <span class="o">=</span> <span class="p">(</span><span class="n">DiscreteFunction</span><span class="o">.</span><span class="n">__rkwargs__</span> <span class="o">+</span>
                   <span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;nt&#39;</span><span class="p">,</span> <span class="s1">&#39;grid&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__init_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># The crucial argument to DugSparseTimeFunction is a sparse</span>
        <span class="c1"># matrix mapping a &quot;source&quot; or &quot;receiver&quot; to a set of locations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;matrix&#39;</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">devito.data.allocators</span> <span class="kn">import</span> <span class="n">default_allocator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_allocator</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;allocator&quot;</span><span class="p">,</span> <span class="n">default_allocator</span><span class="p">())</span>

        <span class="c1"># Rows are locations, columns are source/receivers</span>
        <span class="n">nloc</span><span class="p">,</span> <span class="n">npoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_finalize__</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">npoint</span><span class="o">=</span><span class="n">npoint</span><span class="p">)</span>

        <span class="c1"># Grid points per sparse point</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;MatrixSparseTimeFunction requires parameter `r`&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;MatrixSparseTimeFunction requires r &gt; 0&#39;</span><span class="p">)</span>

            <span class="c1"># convert to dictionary with same size in all dims</span>
            <span class="n">r</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="n">r</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">}</span>

        <span class="c1"># Validate radius is set correctly for all grid dimensions</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dimension </span><span class="si">%s</span><span class="s2"> not specified in r mapping&quot;</span> <span class="o">%</span> <span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="ow">or</span> <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid parameter value r[</span><span class="si">%s</span><span class="s1">] = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]))</span>

        <span class="c1"># TODO is this going to cause some trouble with users of self.r?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span> <span class="o">=</span> <span class="n">r</span>

        <span class="c1"># Get the parallelism dimension for injection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;par_dim&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># This has one value per dimension (e.g. size=3 for 3D)</span>
        <span class="c1"># Maybe this should be unique per SparseFunction,</span>
        <span class="c1"># but I can&#39;t see a need yet.</span>
        <span class="n">ddim</span> <span class="o">=</span> <span class="n">Dimension</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>

        <span class="c1"># Sources have their own Dimension</span>
        <span class="c1"># As do Locations</span>
        <span class="n">locdim</span> <span class="o">=</span> <span class="n">Dimension</span><span class="p">(</span><span class="s1">&#39;loc_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_gridpoints</span> <span class="o">=</span> <span class="n">SubFunction</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_gridpoints&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
            <span class="n">dimensions</span><span class="o">=</span><span class="p">(</span><span class="n">locdim</span><span class="p">,</span> <span class="n">ddim</span><span class="p">),</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nloc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dim</span><span class="p">),</span>
            <span class="n">allocator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_allocator</span><span class="p">,</span>
            <span class="n">space_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># There is a coefficient array per grid dimension</span>
        <span class="c1"># I could pack these into one array but that seems less readable?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolation_coefficients</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolation_coefficients_t_bogus</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rdims</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">rdim</span> <span class="o">=</span> <span class="n">DefaultDimension</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;r</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                    <span class="n">default_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_radius</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rdims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rdim</span><span class="p">)</span>
                <span class="n">coeff_dim</span> <span class="o">=</span> <span class="n">rdim</span>
                <span class="n">coeff_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coeff_dim</span> <span class="o">=</span> <span class="n">d</span>
                <span class="n">coeff_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimension_map</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">glb</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">interpolation_coefficients</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">SubFunction</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_coefficients_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                <span class="n">dimensions</span><span class="o">=</span><span class="p">(</span><span class="n">locdim</span><span class="p">,</span> <span class="n">coeff_dim</span><span class="p">),</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nloc</span><span class="p">,</span> <span class="n">coeff_shape</span><span class="p">),</span>
                <span class="n">allocator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_allocator</span><span class="p">,</span>
                <span class="n">space_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

            <span class="c1"># For the _sub_functions, these must be named attributes of</span>
            <span class="c1"># this SparseFunction object</span>
            <span class="nb">setattr</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;coefficients_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">interpolation_coefficients</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>

        <span class="c1"># We also need arrays to represent the sparse matrix map</span>
        <span class="c1"># The shapes are bogus; these are really only used when</span>
        <span class="c1"># constructing the expression,</span>
        <span class="c1"># - the mpi logic dynamically constructs arrays to feed to the</span>
        <span class="c1"># operator C code.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nnzdim</span> <span class="o">=</span> <span class="n">Dimension</span><span class="p">(</span><span class="s1">&#39;nnz_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># In the non-MPI case, at least, we should fill these in once</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distributor</span><span class="o">.</span><span class="n">nprocs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m_coo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">tocoo</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">nnz_size</span> <span class="o">=</span> <span class="n">m_coo</span><span class="o">.</span><span class="n">nnz</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nnz_size</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_mrow</span> <span class="o">=</span> <span class="n">SubFunction</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;mrow_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
            <span class="n">dimensions</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nnzdim</span><span class="p">,),</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nnz_size</span><span class="p">,),</span>
            <span class="n">space_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">allocator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_allocator</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mcol</span> <span class="o">=</span> <span class="n">SubFunction</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;mcol_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
            <span class="n">dimensions</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nnzdim</span><span class="p">,),</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nnz_size</span><span class="p">,),</span>
            <span class="n">space_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">allocator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_allocator</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mval</span> <span class="o">=</span> <span class="n">SubFunction</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;mval_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">dimensions</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nnzdim</span><span class="p">,),</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nnz_size</span><span class="p">,),</span>
            <span class="n">space_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">allocator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_allocator</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># This loop maintains a map of nnz indices which touch each</span>
        <span class="c1"># coordinate of the parallised injection dimension</span>
        <span class="c1"># This takes the form of a list of nnz indices, and a start/end</span>
        <span class="c1"># position in that list for each index in the parallel dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">par_dim_to_nnz_dim</span> <span class="o">=</span> <span class="n">DynamicDimension</span><span class="p">(</span><span class="s1">&#39;par_dim_to_nnz_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># This map acts as an indirect sort of the sources according to their</span>
        <span class="c1"># position along the parallelisation dimension</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim_to_nnz_map</span> <span class="o">=</span> <span class="n">SubFunction</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;par_dim_to_nnz_map_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
            <span class="n">dimensions</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par_dim_to_nnz_dim</span><span class="p">,),</span>
            <span class="c1"># shape is unknown at this stage</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">space_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim_to_nnz_m</span> <span class="o">=</span> <span class="n">SubFunction</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;par_dim_to_nnz_m_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
            <span class="n">dimensions</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_par_dim</span><span class="p">,),</span>
            <span class="c1"># shape is unknown at this stage</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">space_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim_to_nnz_M</span> <span class="o">=</span> <span class="n">SubFunction</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;par_dim_to_nnz_M_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
            <span class="n">dimensions</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_par_dim</span><span class="p">,),</span>
            <span class="c1"># shape is unknown at this stage</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">space_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distributor</span><span class="o">.</span><span class="n">nprocs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mrow</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">m_coo</span><span class="o">.</span><span class="n">row</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mcol</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">m_coo</span><span class="o">.</span><span class="n">col</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mval</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">m_coo</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># self._fd = generate_fd_shortcuts(self)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">scatter_result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scattered_data</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">free_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The sympy cache holds the symbol references, but we can break the link</span>
        <span class="c1"># between the symbol and the data, thus causing the memory to be freed</span>
        <span class="c1"># This renders the object useless</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gridpoints</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mrow</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mcol</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mval</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolation_coefficients</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">f</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">scatter_result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scattered_data</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_dim</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_dim</span><span class="o">.</span><span class="n">spacing</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">-</span> <span class="n">dt</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">dt</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dt2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_dim</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_dim</span><span class="o">.</span><span class="n">spacing</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">-</span> <span class="n">dt</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">dt</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mrow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mrow</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mcol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mcol</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mval</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">par_dim_to_nnz_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim_to_nnz_map</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">par_dim_to_nnz_m</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim_to_nnz_m</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">par_dim_to_nnz_M</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim_to_nnz_M</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_sub_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;gridpoints&#39;</span><span class="p">,</span>
                <span class="o">*</span><span class="p">[</span><span class="s1">&#39;coefficients_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">],</span>
                <span class="s1">&#39;mrow&#39;</span><span class="p">,</span> <span class="s1">&#39;mcol&#39;</span><span class="p">,</span> <span class="s1">&#39;mval&#39;</span><span class="p">,</span> <span class="s1">&#39;par_dim_to_nnz_map&#39;</span><span class="p">,</span>
                <span class="s1">&#39;par_dim_to_nnz_m&#39;</span><span class="p">,</span> <span class="s1">&#39;par_dim_to_nnz_M&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">r</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span>

    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">u_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p_t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a :class:`sympy.Eq` equation for the interpolation</span>
<span class="sd">        of an expression onto this sparse point collection.</span>

<span class="sd">        :param expr: The expression to interpolate.</span>
<span class="sd">        :param offset: Additional offset from the boundary for</span>
<span class="sd">                       absorbing boundary conditions.</span>
<span class="sd">        :param u_t: (Optional) time index to use for indexing into</span>
<span class="sd">                    field data in `expr`.</span>
<span class="sd">        :param p_t: (Optional) time index to use for indexing into</span>
<span class="sd">                    the sparse point data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">indexify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="c1"># Apply optional time symbol substitutions to expr</span>
        <span class="k">if</span> <span class="n">u_t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">time_dim</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">stepping_dim</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u_t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">u_t</span><span class="p">)</span>

        <span class="n">gridpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gridpoints</span><span class="o">.</span><span class="n">indexed</span>
        <span class="n">mrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mrow</span><span class="o">.</span><span class="n">indexed</span>
        <span class="n">mcol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mcol</span><span class="o">.</span><span class="n">indexed</span>
        <span class="n">mval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mval</span><span class="o">.</span><span class="n">indexed</span>
        <span class="n">tdim</span><span class="p">,</span> <span class="n">pdim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">locdim</span><span class="p">,</span> <span class="n">ddim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gridpoints</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">nnzdim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nnzdim</span>

        <span class="n">row</span> <span class="o">=</span> <span class="n">mrow</span><span class="p">[</span><span class="n">nnzdim</span><span class="p">]</span>

        <span class="n">dim_subs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">pdim</span><span class="p">,</span> <span class="n">mcol</span><span class="p">[</span><span class="n">nnzdim</span><span class="p">])]</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">mval</span><span class="p">[</span><span class="n">nnzdim</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">):</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">rd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolation_coefficients</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span>
            <span class="n">coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolation_coefficients</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">indexed</span>

            <span class="c1"># If radius is set to None, then the coefficient array is</span>
            <span class="c1"># actually the full size of the grid dimension itself</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dim_subs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">rd</span> <span class="o">+</span> <span class="n">gridpoints</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">i</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">d</span> <span class="ow">is</span> <span class="n">rd</span>

            <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coefficients</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">rd</span><span class="p">])</span>

        <span class="c1"># Apply optional time symbol substitutions to lhs of assignment</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">p_t</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">tdim</span><span class="p">,</span> <span class="n">p_t</span><span class="p">)</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">pdim</span><span class="p">,</span> <span class="n">mcol</span><span class="p">[</span><span class="n">nnzdim</span><span class="p">])])</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">dim_subs</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">Inc</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">inject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">u_t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p_t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Symbol for injection of an expression onto a grid</span>

<span class="sd">        :param field: The grid field into which we inject.</span>
<span class="sd">        :param expr: The expression to inject.</span>
<span class="sd">        :param offset: Additional offset from the boundary for</span>
<span class="sd">                       absorbing boundary conditions.</span>
<span class="sd">        :param u_t: (Optional) time index to use for indexing into `field`.</span>
<span class="sd">        :param p_t: (Optional) time index to use for indexing into `expr`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">indexify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">indexify</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>

        <span class="n">tdim</span><span class="p">,</span> <span class="n">pdim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">par_dim_to_nnz_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">par_dim_to_nnz_dim</span>
        <span class="n">locdim</span><span class="p">,</span> <span class="n">ddim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridpoints</span><span class="o">.</span><span class="n">indices</span>

        <span class="c1"># Apply optional time symbol substitutions to field and expr</span>
        <span class="k">if</span> <span class="n">u_t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">u_t</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">p_t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">tdim</span><span class="p">,</span> <span class="n">p_t</span><span class="p">)</span>

        <span class="n">gridpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gridpoints</span><span class="o">.</span><span class="n">indexed</span>
        <span class="n">mrow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mrow</span><span class="o">.</span><span class="n">indexed</span>
        <span class="n">mcol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mcol</span><span class="o">.</span><span class="n">indexed</span>
        <span class="n">mval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mval</span><span class="o">.</span><span class="n">indexed</span>
        <span class="n">partonnz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim_to_nnz_map</span><span class="o">.</span><span class="n">indexed</span>

        <span class="n">nnz_index</span> <span class="o">=</span> <span class="n">partonnz</span><span class="p">[</span><span class="n">par_dim_to_nnz_dim</span><span class="p">]</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">mrow</span><span class="p">[</span><span class="n">nnz_index</span><span class="p">]</span>
        <span class="n">dim_subs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">pdim</span><span class="p">,</span> <span class="n">mcol</span><span class="p">[</span><span class="n">nnz_index</span><span class="p">])]</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">mval</span><span class="p">[</span><span class="n">nnz_index</span><span class="p">]]</span>

        <span class="c1"># Devito requires a fixed ordering of dimensions across</span>
        <span class="c1"># all loops, which means we need to respect that when constructing</span>
        <span class="c1"># the loops for this injection.</span>

        <span class="c1"># to that end, we keep the pairs (x, rx) (y, ry) together in the</span>
        <span class="c1"># ordering.</span>

        <span class="n">par_dim_seen</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">implicit_dims_for_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">tdim</span><span class="p">]</span>
        <span class="n">implicit_dims_for_inject</span> <span class="o">=</span> <span class="p">[</span><span class="n">tdim</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">):</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">rd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolation_coefficients</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">dimensions</span>
            <span class="n">coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolation_coefficients</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">indexed</span>

            <span class="c1"># There are four cases here.</span>
            <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># If d is the parallelism dimension, AND this dimension is</span>
                    <span class="c1"># non-local (i.e. all sources touch all indices, and</span>
                    <span class="c1"># gridpoint for this dim is ignored)</span>
                    <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coefficients</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># d is the parallelism dimension, so the index into</span>
                    <span class="c1"># the coefficients array is derived from the value of</span>
                    <span class="c1"># this dimension minus the gridpoint of the point</span>
                    <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coefficients</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">gridpoints</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">i</span><span class="p">]])</span>

                <span class="c1"># loop dim here is always d</span>
                <span class="n">implicit_dims_for_range</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">implicit_dims_for_inject</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">implicit_dims_for_inject</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">par_dim_to_nnz_dim</span><span class="p">)</span>
                <span class="n">par_dim_seen</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># d is not the parallelism dimension, AND this dimension</span>
                    <span class="c1"># is non-local (i.e. all sources touch all indices,</span>
                    <span class="c1"># and gridpoint for this dim is ignored)</span>

                    <span class="c1"># the loop is therefore over the original dimension d</span>
                    <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coefficients</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
                    <span class="n">loop_dim</span> <span class="o">=</span> <span class="n">d</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># d is not the parallelism dimension, and it _is_</span>
                    <span class="c1"># local. In this case the loop is over the radius dimension</span>
                    <span class="c1"># and we need to substitute d with the offset from the</span>
                    <span class="c1"># grid point</span>
                    <span class="n">dim_subs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">rd</span> <span class="o">+</span> <span class="n">gridpoints</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">i</span><span class="p">]))</span>
                    <span class="n">coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coefficients</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">rd</span><span class="p">])</span>
                    <span class="n">loop_dim</span> <span class="o">=</span> <span class="n">rd</span>

                <span class="n">implicit_dims_for_inject</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_dim</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">par_dim_seen</span><span class="p">:</span>
                    <span class="n">implicit_dims_for_range</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_dim</span><span class="p">)</span>

        <span class="n">rhs</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span> <span class="o">*</span> <span class="n">expr</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">dim_subs</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Eq</span><span class="p">(</span>
                <span class="n">par_dim_to_nnz_dim</span><span class="o">.</span><span class="n">symbolic_min</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim_to_nnz_m</span><span class="p">,</span>
                <span class="n">implicit_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">implicit_dims_for_range</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="n">Eq</span><span class="p">(</span>
                <span class="n">par_dim_to_nnz_dim</span><span class="o">.</span><span class="n">symbolic_max</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim_to_nnz_M</span><span class="p">,</span>
                <span class="n">implicit_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">implicit_dims_for_range</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="n">Inc</span><span class="p">(</span>
                <span class="n">field</span><span class="p">,</span>
                <span class="n">rhs</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">dim_subs</span><span class="p">),</span>
                <span class="n">implicit_dims</span><span class="o">=</span><span class="n">IgnoreDimSort</span><span class="p">(</span><span class="n">implicit_dims_for_inject</span><span class="p">),</span>
            <span class="p">),</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__indices_setup__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the default dimension indices for a given data shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">Dimension</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="s1">&#39;p_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">dimensions</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">__shape_setup__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># This happens before __init__, so we have to get &#39;npoint&#39;</span>
        <span class="c1"># from the matrix</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">npoint</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;matrix&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nt&#39;</span><span class="p">),</span> <span class="n">npoint</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_arg_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a tuple of argument names introduced by this function.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridpoints</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                     <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolation_coefficients</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gridpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gridpoints</span>

    <span class="k">def</span> <span class="nf">_rank_to_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each rank in self.grid.distributor, return</span>
<span class="sd">        a numpy array of int32s for the positions within</span>
<span class="sd">        this rank&#39;s self.gridpoints/self.interpolation_coefficients (i.e.</span>
<span class="sd">        the locdim) which must be injected into that rank.</span>

<span class="sd">        Any given location may require injection into several</span>
<span class="sd">        ranks, based on the radius of the injection stencil</span>
<span class="sd">        and its proximity to a rank boundary.</span>

<span class="sd">        It is assumed, for now, that any given location may be</span>
<span class="sd">        completely sampled from within one rank - so when</span>
<span class="sd">        gathering the data, any point sampled from more than</span>
<span class="sd">        one rank may have duplicates discarded.  This implies</span>
<span class="sd">        that the radius of the sampling is less than</span>
<span class="sd">        the halo size of the Functions being sampled from.</span>
<span class="sd">        It also requires that the halos be exchanged before</span>
<span class="sd">        interpolation (must verify that this occurs).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">distributor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distributor</span>

        <span class="c1"># Along each dimension, the coordinate indices are broken into</span>
        <span class="c1"># 2*decomposition_size+3 groups, numbered starting at 0</span>

        <span class="c1"># Group 2*i contributes only to rank i-1</span>
        <span class="c1"># Group 2*i+1 contributes to rank i-1 and rank i</span>

        <span class="c1"># Obviously this means groups 0 and 1 are &quot;bad&quot; - they contribute</span>
        <span class="c1">#  to points to the left of the domain (rank -1)</span>
        <span class="c1"># So is group 2*decomp_size+1 and 2*decomp_size+2</span>
        <span class="c1">#  (these contributes to rank &quot;decomp_size&quot;)</span>

        <span class="c1"># binned_gridpoints will hold which group the particular</span>
        <span class="c1"># point is along that decomposed dimension.</span>
        <span class="n">binned_gridpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gridpoints</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">dim_group_dim_rank</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">idim</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">):</span>
            <span class="n">decomp</span> <span class="o">=</span> <span class="n">distributor</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="n">idim</span><span class="p">]</span>
            <span class="n">decomp_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">decomp</span><span class="p">)</span>
            <span class="n">dim_breaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="n">decomp_size</span><span class="o">+</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

            <span class="n">dim_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dim_r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># size is the whole grid</span>
                <span class="n">dim_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimension_map</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">glb</span>

            <span class="c1"># Define the split</span>
            <span class="n">dim_breaks</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">decomp_part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">decomp_part</span> <span class="ow">in</span> <span class="n">decomp</span><span class="p">]</span>
            <span class="n">dim_breaks</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">decomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">dim_breaks</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">decomp_part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">decomp_part</span> <span class="ow">in</span> <span class="n">decomp</span><span class="p">]</span>
            <span class="n">dim_breaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">decomp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Handle the radius is None case by ensuring we treat</span>
            <span class="c1"># all grid points in that direction as zero</span>
            <span class="n">gridpoints_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gridpoints</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">idim</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gridpoints_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">gridpoints_dim</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">binned_gridpoints</span><span class="p">[:,</span> <span class="n">idim</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span>
                    <span class="n">gridpoints_dim</span><span class="p">,</span> <span class="n">dim_breaks</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;decomposition failed!  Are some ranks too skinny?&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

            <span class="n">this_group_rank_map</span> <span class="o">=</span> <span class="p">{</span>
                <span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="kc">None</span><span class="p">},</span>
                <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
                <span class="o">**</span><span class="p">{</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="n">i</span><span class="p">}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">decomp_size</span><span class="p">)},</span>
                <span class="o">**</span><span class="p">{</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">decomp_size</span><span class="o">-</span><span class="mi">1</span><span class="p">)},</span>
                <span class="mi">2</span><span class="o">*</span><span class="n">decomp_size</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="n">decomp_size</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">},</span>
                <span class="mi">2</span><span class="o">*</span><span class="n">decomp_size</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="kc">None</span><span class="p">}}</span>

            <span class="n">dim_group_dim_rank</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_group_rank_map</span><span class="p">)</span>

        <span class="c1"># This allows the points to be grouped into non-overlapping sets</span>
        <span class="c1"># based on their bin in each dimension.  For each set we build a list</span>
        <span class="c1"># of points.</span>
        <span class="n">bins</span><span class="p">,</span> <span class="n">inverse</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
            <span class="n">binned_gridpoints</span><span class="p">,</span>
            <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># inverse is now a &quot;unique bin number&quot; for each point gridpoints</span>
        <span class="c1"># we want to turn that into a list of points for each bin</span>
        <span class="c1"># so we argsort</span>
        <span class="n">inverse_argsort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">inverse</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">cumulative_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
        <span class="n">gp_map</span> <span class="o">=</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">bi</span><span class="p">):</span> <span class="n">inverse_argsort</span><span class="p">[</span><span class="n">cci</span><span class="o">-</span><span class="n">ci</span><span class="p">:</span><span class="n">cci</span><span class="p">]</span>
                  <span class="k">for</span> <span class="n">bi</span><span class="p">,</span> <span class="n">cci</span><span class="p">,</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">cumulative_counts</span><span class="p">,</span> <span class="n">counts</span><span class="p">)</span>
                  <span class="p">}</span>

        <span class="c1"># the result is now going to be a concatenation of these lists</span>
        <span class="c1"># for each of the output ranks</span>
        <span class="c1"># each bin has a set of ranks -&gt; each rank has a set (possibly empty)</span>
        <span class="c1"># of bins</span>

        <span class="c1"># For each rank get the per-dimension coordinates</span>
        <span class="c1"># TODO maybe we should cache this on the distributor</span>
        <span class="n">dim_ranks_to_glb</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">distributor</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Get_coords</span><span class="p">(</span><span class="n">rank</span><span class="p">)):</span> <span class="n">rank</span>
            <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">distributor</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">())}</span>

        <span class="n">global_rank_to_bins</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
        <span class="k">for</span> <span class="n">bi</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">:</span>
            <span class="c1"># This is a list of sets for the dimension-specific rank</span>
            <span class="n">dim_rank_sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">dgdr</span><span class="p">[</span><span class="n">bii</span><span class="p">]</span>
                             <span class="k">for</span> <span class="n">dgdr</span><span class="p">,</span> <span class="n">bii</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dim_group_dim_rank</span><span class="p">,</span> <span class="n">bi</span><span class="p">)]</span>

            <span class="c1"># Convert these to an absolute rank</span>
            <span class="c1"># This is where we will throw a KeyError if there are points OOB</span>
            <span class="k">for</span> <span class="n">dim_ranks</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">dim_rank_sets</span><span class="p">):</span>
                <span class="n">global_rank</span> <span class="o">=</span> <span class="n">dim_ranks_to_glb</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dim_ranks</span><span class="p">)]</span>
                <span class="n">global_rank_to_bins</span>\
                    <span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">global_rank</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>\
                    <span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">bi</span><span class="p">))</span>

        <span class="n">empty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span>
            <span class="n">empty</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="n">gp_map</span><span class="p">[</span><span class="n">bi</span><span class="p">]</span> <span class="k">for</span> <span class="n">bi</span> <span class="ow">in</span> <span class="n">global_rank_to_bins</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="p">[])]))</span>
            <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">distributor</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Get_size</span><span class="p">())]</span>

    <span class="k">def</span> <span class="nf">_build_par_dim_to_nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">active_gp</span><span class="p">,</span> <span class="n">active_mrow</span><span class="p">):</span>
        <span class="c1"># The case where we parallelise over a non-local index is suboptimal, but</span>
        <span class="c1"># supported. In this case, the actual grid point locations are ignored</span>
        <span class="c1"># and all points are touched.</span>

        <span class="n">pardim_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_par_dim</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_par_dim</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># early exit with degenerate case - no reordering and all coordinate</span>
            <span class="c1"># values touch all parts of the array</span>
            <span class="n">nnz_M</span> <span class="o">=</span> <span class="n">active_mrow</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim_to_nnz_map</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">active_mrow</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim_to_nnz_m</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape_local</span><span class="p">[</span><span class="n">pardim_index</span><span class="p">],),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span>
                <span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim_to_nnz_M</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape_local</span><span class="p">[</span><span class="n">pardim_index</span><span class="p">],),</span> <span class="n">nnz_M</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span>
                <span class="p">),</span>
            <span class="p">}</span>

        <span class="c1"># Get the radius along the parallel dimension</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_par_dim</span><span class="p">]</span>

        <span class="c1"># now, the parameters can be devito.Data, which doesn&#39;t like fancy indexing</span>
        <span class="c1"># very much. So, we convert to regular numpy arrays</span>
        <span class="n">active_gp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">active_gp</span><span class="p">)</span>
        <span class="n">active_mrow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">active_mrow</span><span class="p">)</span>

        <span class="c1"># sort the injected nonzero indices by parallel coordinate</span>
        <span class="n">pardim_coordinates_nnz</span> <span class="o">=</span> <span class="n">active_gp</span><span class="p">[</span><span class="n">active_mrow</span><span class="p">,</span> <span class="n">pardim_index</span><span class="p">]</span>
        <span class="n">reordering</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">pardim_coordinates_nnz</span><span class="p">)</span>
        <span class="n">pardim_reordered</span> <span class="o">=</span> <span class="n">pardim_coordinates_nnz</span><span class="p">[</span><span class="n">reordering</span><span class="p">]</span>

        <span class="c1"># now each x coordinate that we inject into has a range</span>
        <span class="c1"># of relevant entries in the reordered array</span>

        <span class="c1"># we don&#39;t worry about MPI here; by the time this function is called,</span>
        <span class="c1"># all gridpoints have been renumbered to local offsets</span>

        <span class="c1"># this coordinate is touched by any source with gridpoint &gt;= x - r + 1</span>
        <span class="c1"># and gridpoint &lt;= x</span>
        <span class="n">all_xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape_local</span><span class="p">[</span><span class="n">pardim_index</span><span class="p">])</span>

        <span class="c1"># This should satisfy:</span>
        <span class="c1"># x_reordered[i-1] &lt; x - r + 1 &lt;= x_reordered[i]</span>
        <span class="n">reordered_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">pardim_reordered</span><span class="p">,</span> <span class="n">all_xs</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
        <span class="c1"># x_reordered[i-1] &lt;= x &lt; x_reordered[i]</span>
        <span class="n">reordered_M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">pardim_reordered</span><span class="p">,</span> <span class="n">all_xs</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># return output suitable for scatter</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim_to_nnz_map</span><span class="p">:</span> <span class="n">reordering</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim_to_nnz_m</span><span class="p">:</span> <span class="n">reordered_m</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_par_dim_to_nnz_M</span><span class="p">:</span> <span class="n">reordered_M</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">manual_scatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">data_all_zero</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">distributor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distributor</span>

        <span class="k">if</span> <span class="n">distributor</span><span class="o">.</span><span class="n">nprocs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scattered_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scatter_result</span> <span class="o">=</span> <span class="p">{</span>
                <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="o">**</span><span class="p">{</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sub_functions</span>
                <span class="p">},</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mrow</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mrow</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mcol</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcol</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mval</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mval</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_build_par_dim_to_nnz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridpoints</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mrow</span><span class="o">.</span><span class="n">data</span><span class="p">),</span>
            <span class="p">}</span>
            <span class="k">return</span>

        <span class="c1"># Generate the matrix arrays</span>
        <span class="n">m_coo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">tocoo</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># HACK: for now, only take npoints != 0 on rank 0</span>
        <span class="c1"># Broadcast all the data, gridpoints, coefficients to all ranks</span>
        <span class="c1"># Each rank then ignores any of the data which isn&#39;t in its own</span>
        <span class="c1">#  domain.</span>
        <span class="k">if</span> <span class="n">distributor</span><span class="o">.</span><span class="n">myrank</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">npoint</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can only accept sources/receivers on rank 0&quot;</span><span class="p">)</span>

        <span class="c1"># args[self.mrow.name] = m_coo.row.copy()</span>
        <span class="c1"># args[self.mcol.name] = m_coo.col.copy()</span>
        <span class="c1"># args[self.mval.name] = m_coo.data.copy()</span>
        <span class="c1"># args.update(self.nnzdim._arg_defaults(size=m_coo.nnz))</span>

        <span class="c1"># Send out data</span>
        <span class="c1"># Send out gridpoints</span>
        <span class="c1"># Send out coefficients</span>
        <span class="c1"># Send out matrix rows, cols, data</span>
        <span class="n">r_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>

        <span class="n">npoint</span><span class="p">,</span> <span class="n">nloc</span><span class="p">,</span> <span class="n">nnz</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">r_tuple_bcast</span><span class="p">,</span> <span class="n">nt</span> <span class="o">=</span> <span class="n">distributor</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npoint</span><span class="p">,</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">_gridpoints</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
             <span class="n">m_coo</span><span class="o">.</span><span class="n">nnz</span><span class="p">,</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">_gridpoints</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
             <span class="n">r_tuple</span><span class="p">,</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_time_position</span><span class="p">]),</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># important that all ranks have the same ndims and same r</span>
        <span class="k">assert</span> <span class="n">r_tuple</span> <span class="o">==</span> <span class="n">r_tuple_bcast</span>
        <span class="k">assert</span> <span class="n">ndim</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gridpoints</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># handle None radius</span>
        <span class="n">r_tuple_no_none</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">ri</span> <span class="k">if</span> <span class="n">ri</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimension_map</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">glb</span>
            <span class="k">for</span> <span class="n">ri</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">r_tuple</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># now all ranks can allocate the buffers to receive into</span>
        <span class="k">if</span> <span class="n">distributor</span><span class="o">.</span><span class="n">myrank</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data_all_zero</span><span class="p">:</span>
                <span class="n">scattered_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nt</span><span class="p">,</span> <span class="n">npoint</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scattered_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nt</span><span class="p">,</span> <span class="n">npoint</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">scattered_gp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nloc</span><span class="p">,</span> <span class="n">ndim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">scattered_coeffs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nloc</span><span class="p">,</span> <span class="n">r_tuple_no_none</span><span class="p">[</span><span class="n">idim</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">idim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">scattered_mrow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nnz</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">scattered_mcol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nnz</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">scattered_mval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nnz</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scattered_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

            <span class="c1"># These are copies because we mess with them down below</span>
            <span class="n">scattered_gp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gridpoints</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">scattered_coeffs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">interpolation_coefficients</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">]</span>
            <span class="n">scattered_mrow</span> <span class="o">=</span> <span class="n">m_coo</span><span class="o">.</span><span class="n">row</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">scattered_mcol</span> <span class="o">=</span> <span class="n">m_coo</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">scattered_mval</span> <span class="o">=</span> <span class="n">m_coo</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">data_all_zero</span><span class="p">:</span>
            <span class="n">distributor</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">scattered_data</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="p">[</span><span class="n">scattered_gp</span><span class="p">,</span> <span class="o">*</span><span class="n">scattered_coeffs</span><span class="p">,</span>
                    <span class="n">scattered_mrow</span><span class="p">,</span> <span class="n">scattered_mcol</span><span class="p">,</span> <span class="n">scattered_mval</span><span class="p">]:</span>
            <span class="n">distributor</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Bcast</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># now recreate the matrix to only contain points in our</span>
        <span class="c1"># local domain.</span>
        <span class="c1"># along each dimension, each point is in one of 5 groups</span>
        <span class="c1">#  0 - completely to the left</span>
        <span class="c1">#  1 - to the left, but the injection stencil touches our domain</span>
        <span class="c1">#  2 - completely in our domain</span>
        <span class="c1">#  3 - in the domain, but the injection stencil includes points</span>
        <span class="c1">#      to the right</span>
        <span class="c1">#  4 - completely to the right</span>
        <span class="n">active_mrow</span> <span class="o">=</span> <span class="n">scattered_mrow</span>
        <span class="n">active_mcol</span> <span class="o">=</span> <span class="n">scattered_mcol</span>
        <span class="n">active_mval</span> <span class="o">=</span> <span class="n">scattered_mval</span>

        <span class="c1"># first, build a reduced matrix excluding any points outside our domain</span>
        <span class="k">for</span> <span class="n">idim</span><span class="p">,</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">mycoord</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">distributor</span><span class="o">.</span><span class="n">mycoords</span><span class="p">)):</span>
            <span class="n">_left</span> <span class="o">=</span> <span class="n">distributor</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="n">idim</span><span class="p">][</span><span class="n">mycoord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_right</span> <span class="o">=</span> <span class="n">distributor</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="n">idim</span><span class="p">][</span><span class="n">mycoord</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">this_dim_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="n">effective_gridpoints</span> <span class="o">=</span> <span class="n">scattered_gp</span><span class="p">[</span><span class="n">active_mrow</span><span class="p">,</span> <span class="n">idim</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">this_dim_r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">this_dim_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimension_map</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">glb</span>
                <span class="n">effective_gridpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">effective_gridpoints</span><span class="p">)</span>

            <span class="c1"># rewrite the matrix to remove the rows in groups 0 and 4</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">effective_gridpoints</span> <span class="o">&gt;=</span> <span class="n">_left</span> <span class="o">-</span> <span class="n">this_dim_r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">effective_gridpoints</span> <span class="o">&lt;</span> <span class="n">_right</span><span class="p">))</span>

            <span class="n">which</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">active_mrow</span> <span class="o">=</span> <span class="n">active_mrow</span><span class="p">[</span><span class="n">which</span><span class="p">]</span>
            <span class="n">active_mcol</span> <span class="o">=</span> <span class="n">active_mcol</span><span class="p">[</span><span class="n">which</span><span class="p">]</span>
            <span class="n">active_mval</span> <span class="o">=</span> <span class="n">active_mval</span><span class="p">[</span><span class="n">which</span><span class="p">]</span>

        <span class="c1"># then, zero any of the coefficients which refer to points outside our</span>
        <span class="c1"># domain.  Do this on all the gridpoints for now, since this is a hack</span>
        <span class="c1"># anyway</span>
        <span class="k">for</span> <span class="n">idim</span><span class="p">,</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">mycoord</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">distributor</span><span class="o">.</span><span class="n">mycoords</span><span class="p">)):</span>
            <span class="n">_left</span> <span class="o">=</span> <span class="n">distributor</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="n">idim</span><span class="p">][</span><span class="n">mycoord</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_right</span> <span class="o">=</span> <span class="n">distributor</span><span class="o">.</span><span class="n">decomposition</span><span class="p">[</span><span class="n">idim</span><span class="p">][</span><span class="n">mycoord</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># points to the left have the first few coeffs zeroed</span>
            <span class="n">this_dim_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="n">effective_gridpoints</span> <span class="o">=</span> <span class="n">scattered_gp</span><span class="p">[:,</span> <span class="n">idim</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">this_dim_r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">this_dim_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimension_map</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">glb</span>
                <span class="n">effective_gridpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">effective_gridpoints</span><span class="p">)</span>

            <span class="n">trim_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">_left</span> <span class="o">-</span> <span class="n">effective_gridpoints</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">this_dim_r</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ir</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">this_dim_r</span><span class="p">):</span>
                <span class="c1"># which points need zeroing?</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">trim_size</span> <span class="o">&gt;</span> <span class="n">ir</span><span class="p">)</span>
                <span class="n">scattered_coeffs</span><span class="p">[</span><span class="n">idim</span><span class="p">][</span><span class="n">mask</span><span class="p">,</span> <span class="n">ir</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># points to the right have the last few coeffs zeroed</span>
            <span class="n">trim_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span>
                <span class="n">effective_gridpoints</span> <span class="o">-</span> <span class="p">(</span><span class="n">_right</span> <span class="o">-</span> <span class="n">this_dim_r</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">this_dim_r</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ir</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">this_dim_r</span><span class="p">):</span>
                <span class="c1"># which points need zeroing?</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">trim_size</span> <span class="o">&gt;</span> <span class="n">ir</span><span class="p">)</span>
                <span class="n">scattered_coeffs</span><span class="p">[</span><span class="n">idim</span><span class="p">][</span><span class="n">mask</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">ir</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># finally, we translate to local coordinates</span>
            <span class="c1"># no need for this in the broadcasted dimensions</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">scattered_gp</span><span class="p">[:,</span> <span class="n">idim</span><span class="p">]</span> <span class="o">-=</span> <span class="n">_left</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">scattered_data</span> <span class="o">=</span> <span class="n">scattered_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scatter_result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="bp">self</span><span class="p">:</span> <span class="n">scattered_data</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gridpoints</span><span class="p">:</span> <span class="n">scattered_gp</span><span class="p">,</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">interpolation_coefficients</span><span class="p">[</span><span class="n">d</span><span class="p">]:</span> <span class="n">scattered_coeffs</span><span class="p">[</span><span class="n">idim</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">idim</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
            <span class="p">},</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mrow</span><span class="p">:</span> <span class="n">active_mrow</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mcol</span><span class="p">:</span> <span class="n">active_mcol</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mval</span><span class="p">:</span> <span class="n">active_mval</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_build_par_dim_to_nnz</span><span class="p">(</span><span class="n">scattered_gp</span><span class="p">,</span> <span class="n">active_mrow</span><span class="p">),</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_dist_scatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatter_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;_dist_scatter called before manual_scatter called&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatter_result</span>

    <span class="c1"># The implementation in AbstractSparseFunction now relies on us</span>
    <span class="c1"># having a .coordinates property, which we don&#39;t have.</span>
    <span class="k">def</span> <span class="nf">_arg_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataobj</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">alias</span> <span class="k">if</span> <span class="n">alias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AbstractSparseFunction</span><span class="p">):</span>
            <span class="c1"># Gather into `self.data`</span>
            <span class="n">key</span><span class="o">.</span><span class="n">_dist_gather</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_C_as_ndarray</span><span class="p">(</span><span class="n">dataobj</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distributor</span><span class="o">.</span><span class="n">nprocs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Don&#39;t know how to gather data from an &quot;</span>
                                      <span class="s2">&quot;object of type `</span><span class="si">%s</span><span class="s2">`&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">manual_gather</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># data, in this case, is set to whatever dist_scatter provided?</span>
        <span class="c1"># on rank 0, this is the original data array (hack...)</span>
        <span class="n">distributor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">distributor</span>

        <span class="c1"># If not using MPI, don&#39;t waste time</span>
        <span class="k">if</span> <span class="n">distributor</span><span class="o">.</span><span class="n">nprocs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># This relies on all ranks having a copy of all data. Which feels &quot;bad&quot;.</span>
        <span class="k">if</span> <span class="n">distributor</span><span class="o">.</span><span class="n">myrank</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">distributor</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Reduce</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scattered_data</span><span class="p">,</span>
                <span class="kc">None</span><span class="p">,</span>
                <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span><span class="p">,</span>
                <span class="n">root</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distributor</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Reduce</span><span class="p">(</span>
                <span class="n">MPI</span><span class="o">.</span><span class="n">IN_PLACE</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scattered_data</span><span class="p">,</span>  <span class="c1"># Note: on rank 0 data === scattered_data.</span>
                <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span><span class="p">,</span>
                <span class="n">root</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_dist_gather</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2019, Devito.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>