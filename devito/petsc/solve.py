from devito.types.equation import PetscEq
from devito.tools import filter_ordered, as_tuple
from devito.types import Symbol, SteppingDimension, TimeDimension
from devito.operations.solve import eval_time_derivatives
from devito.symbolics import retrieve_functions, retrieve_dimensions

from devito.petsc.types import (LinearSolverMetaData, PETScArray, DMDALocalInfo,
                                FieldData, MultipleFieldData, Jacobian, Residual,
                                MixedResidual, MixedJacobian, InitialGuess)
from devito.petsc.types.equation import EssentialBC
from devito.petsc.solver_parameters import (linear_solver_parameters,
                                            format_options_prefix)


__all__ = ['PETScSolve']


# TODO: Rename this to petsc_solve, petscsolve?
def PETScSolve(target_exprs, target=None, solver_parameters=None,
               options_prefix=None, get_info=[]):
    """
    Returns a symbolic expression representing a linear PETSc solver,
    enriched with all the necessary metadata for execution within an `Operator`.
    When passed to an `Operator`, this symbolic equation triggers code generation
    and lowering to the PETSc backend.

    This function supports both single- and multi-target systems. In the multi-target
    (mixed system) case, the solution vector spans all provided target fields.

    Parameters
    ----------
    target_exprs : Eq or list of Eq, or dict of Function-like -> Eq or list of Eq
        The targets and symbolic expressions defining the system to be solved.

        - Single-field problem:
            Pass a single Eq or list of Eq, and specify `target` separately:
                PETScSolve(Eq1, target)
                PETScSolve([Eq1, Eq2], target)

        - Multi-field (mixed) problem:
            Pass a dictionary mapping each target field to its Eq(s):
                PETScSolve({u: Eq1, v: Eq2})
                PETScSolve({u: [Eq1, Eq2], v: [Eq3, Eq4]})

    target : Function-like
        The function (e.g., `Function`, `TimeFunction`) into which the linear
        system solves. This represents the solution vector updated by the solver.

    solver_parameters : dict, optional
        PETSc solver options.

        Descriptions (not exhaustive):
        - 'ksp_type':    Specifies the Krylov method (e.g., 'gmres', 'cg').
        - 'pc_type':     Specifies the preconditioner type (e.g., ...).
        - 'ksp_rtol':    Relative convergence tolerance for KSP solvers.
        - 'ksp_atol':    Absolute convergence tolerance for KSP solvers.
        - 'ksp_divtol':  Divergence tolerance, amount residual norm can increase before
                        `KSPConvergedDefault()` concludes that the method is diverging.
        - 'ksp_max_it':  Maximum number of KSP iterations to use.
        - 'snes_type':   Type of SNES solver; 'ksponly' is used for linear solves.

        References:
        - KSP types: https://petsc.org/main/manualpages/KSP/KSPType/
        - PC types: https://petsc.org/main/manualpages/PC/PCType/
        - KSP tolerances: https://petsc.org/main/manualpages/KSP/KSPSetTolerances/
        - SNES type: https://petsc.org/main/manualpages/SNES/SNESType/

    options_prefix : str, optional
        Prefix for the solver, used to configure options via the command line. If not
        provided, a default prefix is generated by Devito.

    get_info : list[str], optional
        A list of PETSc API functions (case insensitive) to collect statistics
        from the solver.

        List of available functions:
        - ['kspgetiterationnumber', 'kspgettolerances', 'kspgetconvergedreason',
           'kspgettype', 'kspgetnormtype', 'snesgetiterationnumber']

    Returns
    -------
    Eq:
        A symbolic expression that wraps the linear solver.
        This can be passed directly to a Devito Operator.
    """
    if target is not None:
        return InjectSolve(solver_parameters, {target: target_exprs},
                           options_prefix, get_info).build_expr()
    else:
        return InjectMixedSolve(solver_parameters, target_exprs,
                                options_prefix, get_info).build_expr()


class InjectSolve:
    def __init__(self, solver_parameters=None, target_exprs=None, options_prefix=None,
                 get_info=[]):
        self.solver_parameters = linear_solver_parameters(solver_parameters)
        self.time_mapper = None
        self.target_exprs = target_exprs
        # The original options prefix provided by the user
        self.user_prefix = options_prefix
        self.formatted_prefix = format_options_prefix(options_prefix)
        self.get_info = [f.lower() for f in get_info]

    def build_expr(self):
        target, funcs, field_data = self.linear_solve_args()
        # Placeholder expression for inserting calls to the solver

        linear_solve = LinearSolverMetaData(
            funcs,
            solver_parameters=self.solver_parameters,
            field_data=field_data,
            time_mapper=self.time_mapper,
            localinfo=localinfo,
            user_prefix=self.user_prefix,
            formatted_prefix=self.formatted_prefix,
            get_info=self.get_info
        )
        return PetscEq(target, linear_solve)

    def linear_solve_args(self):
        target, exprs = next(iter(self.target_exprs.items()))
        exprs = as_tuple(exprs)

        funcs = get_funcs(exprs)
        self.time_mapper = generate_time_mapper(exprs)
        arrays = self.generate_arrays(target)

        exprs = sorted(exprs, key=lambda e: not isinstance(e, EssentialBC))

        jacobian = Jacobian(target, exprs, arrays, self.time_mapper)
        residual = Residual(target, exprs, arrays, self.time_mapper, jacobian.scdiag)
        initial_guess = InitialGuess(target, exprs, arrays, self.time_mapper)

        field_data = FieldData(
            target=target,
            jacobian=jacobian,
            residual=residual,
            initial_guess=initial_guess,
            arrays=arrays
        )

        return target, funcs, field_data

    def generate_arrays(self, *targets):
        return {
            t: {
                p: PETScArray(
                    name=f'{p}_{t.name}',
                    target=t,
                    liveness='eager',
                    localinfo=localinfo
                )
                for p in prefixes
            }
            for t in targets
        }


class InjectMixedSolve(InjectSolve):

    def linear_solve_args(self):
        exprs = []
        for e in self.target_exprs.values():
            exprs.extend(e)

        funcs = get_funcs(exprs)
        self.time_mapper = generate_time_mapper(exprs)

        targets = list(self.target_exprs.keys())
        arrays = self.generate_arrays(*targets)

        jacobian = MixedJacobian(
            self.target_exprs, arrays, self.time_mapper
        )

        residual = MixedResidual(
            self.target_exprs, arrays, self.time_mapper,
            jacobian.target_scaler_mapper
        )

        all_data = MultipleFieldData(
            targets=targets,
            arrays=arrays,
            jacobian=jacobian,
            residual=residual
        )

        return targets[0], funcs, all_data


def get_funcs(exprs):
    funcs = [
        f for e in exprs
        for f in retrieve_functions(eval_time_derivatives(e.lhs - e.rhs))
    ]
    return as_tuple(filter_ordered(funcs))


def generate_time_mapper(exprs):
    """
    Replace time indices with `Symbols` in expressions used within
    PETSc callback functions. These symbols are Uxreplaced at the IET
    level to align with the `TimeDimension` and `ModuloDimension` objects
    present in the initial lowering.
    NOTE: All functions used in PETSc callback functions are attached to
    the `SolverMetaData` object, which is passed through the initial lowering
    (and subsequently dropped and replaced with calls to run the solver).
    Therefore, the appropriate time loop will always be correctly generated inside
    the main kernel.
    Examples
    --------
    >>> exprs = (Eq(f1(t + dt, x, y), g1(t + dt, x, y) + g2(t, x, y)*f1(t, x, y)),)
    >>> generate_time_mapper(exprs)
    {t + dt: tau0, t: tau1}
    """
    # First, map any actual TimeDimensions
    time_indices = [d for d in retrieve_dimensions(exprs) if isinstance(d, TimeDimension)]

    funcs = get_funcs(exprs)

    time_indices.extend(list({
        i if isinstance(d, SteppingDimension) else d
        for f in funcs
        for i, d in zip(f.indices, f.dimensions)
        if d.is_Time
    }))
    tau_symbs = [Symbol('tau%d' % i) for i in range(len(time_indices))]
    return dict(zip(time_indices, tau_symbs))


localinfo = DMDALocalInfo(name='info', liveness='eager')
prefixes = ['y', 'x', 'f', 'b']
