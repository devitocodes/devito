from functools import cached_property

from devito.ir.iet import Uxreplace, DummyExpr
from devito.symbolics import FieldFromPointer, cast, FieldFromComposite
from devito.symbolics.unevaluation import Mul

from devito.petsc.iet.nodes import petsc_call


class TimeIndependent:
    def __init__(self, **kwargs):
        self.inject_solve = kwargs.get('inject_solve')
        self.iters = kwargs.get('iters')
        self.sobjs = kwargs.get('solver_objs')
        self.kwargs = kwargs
        self.origin_to_moddim = self._origin_to_moddim_mapper(self.iters)
        self.time_idx_to_symb = self.inject_solve.expr.rhs.time_mapper

    def _origin_to_moddim_mapper(self, iters):
        return {}

    def uxreplace_time(self, body):
        return body

    def place_array(self, target):
        return ()

    def reset_array(self, target):
        return ()

    def assign_time_iters(self, struct):
        return []


class TimeDependent(TimeIndependent):
    """
    A class for managing time-dependent solvers.
    This includes scenarios where the target is not directly a `TimeFunction`,
    but depends on other functions that are.
    Outline of time loop abstraction with PETSc:
    - At PETScSolve, time indices are replaced with temporary `Symbol` objects
      via a mapper (e.g., {t: tau0, t + dt: tau1}) to prevent the time loop
      from being generated in the callback functions. These callbacks, needed
      for each `SNESSolve` at every time step, don't require the time loop, but
      may still need access to data from other time steps.
    - All `Function` objects are passed through the initial lowering via the
      `SolverMetaData` object, ensuring the correct time loop is generated
      in the main kernel.
    - Another mapper is created based on the modulo dimensions
      generated by the `SolverMetaData` object in the main kernel
      (e.g., {time: time, t: t0, t + 1: t1}).
    - These two mappers are used to generate a final mapper `symb_to_moddim`
      (e.g. {tau0: t0, tau1: t1}) which is used at the IET level to
      replace the temporary `Symbol` objects in the callback functions with
      the correct modulo dimensions.
    - Modulo dimensions are updated in the matrix context struct at each time
      step and can be accessed in the callback functions where needed.
    """
    @property
    def time_spacing(self):
        return self.inject_solve.expr.rhs.grid.stepping_dim.spacing

    @cached_property
    def symb_to_moddim(self):
        """
        Maps temporary `Symbol` objects created during `PETScSolve` to their
        corresponding modulo dimensions (e.g. creates {tau0: t0, tau1: t1}).
        """
        mapper = {
            v: k.xreplace({self.time_spacing: 1, -self.time_spacing: -1})
            for k, v in self.time_idx_to_symb.items()
        }
        return {symb: self.origin_to_moddim[mapper[symb]] for symb in mapper}

    def is_target_time(self, target):
        return any(i.is_Time for i in target.dimensions)

    def target_time(self, target):
        target_time = [
            i for i, d in zip(target.indices, target.dimensions)
            if d.is_Time
        ]
        assert len(target_time) == 1
        target_time = target_time.pop()
        return target_time

    def uxreplace_time(self, body):
        return Uxreplace(self.symb_to_moddim).visit(body)

    def _origin_to_moddim_mapper(self, iters):
        """
        Creates a mapper of the origin of the time dimensions to their corresponding
        modulo dimensions from a list of `Iteration` objects.
        Examples
        --------
        >>> iters
        (<WithProperties[affine,sequential]::Iteration time[t0,t1]; (time_m, time_M, 1)>,
         <WithProperties[affine,parallel,parallel=]::Iteration x; (x_m, x_M, 1)>)
        >>> _origin_to_moddim_mapper(iters)
        {time: time, t: t0, t + 1: t1}
        """
        time_iter = [i for i in iters if any(d.is_Time for d in i.dimensions)]
        mapper = {}

        if not time_iter:
            return mapper

        for i in time_iter:
            for d in i.dimensions:
                if d.is_Modulo:
                    mapper[d.origin] = d
                elif d.is_Time:
                    mapper[d] = d
        return mapper

    def place_array(self, target):
        """
        In the case that the actual target is time-dependent e.g a `TimeFunction`,
        a pointer to the first element in the array that will be updated during
        the time step is passed to VecPlaceArray().
        Examples
        --------
        >>> target
        f1(time + dt, x, y)
        >>> calls = place_array(target)
        >>> print(List(body=calls))
        float * f1_ptr0 = (time + 1)*localsize0 + (float*)(f1_vec->data);
        PetscCall(VecPlaceArray(xlocal0,f1_ptr0));
        >>> target
        f1(t + dt, x, y)
        >>> calls = place_array(target)
        >>> print(List(body=calls))
        float * f1_ptr0 = t1*localsize0 + (float*)(f1_vec->data);
        PetscCall(VecPlaceArray(xlocal0,f1_ptr0));
        """
        sobjs = self.sobjs

        if self.is_target_time(target):
            mapper = {self.time_spacing: 1, -self.time_spacing: -1}

            target_time = self.target_time(target).xreplace(mapper)
            target_time = self.origin_to_moddim.get(target_time, target_time)

            xlocal = sobjs.get(f'xlocal{target.name}', sobjs['xlocal'])
            start_ptr = sobjs[f'{target.name}_ptr']

            caster = cast(target.dtype, '*')
            return (
                DummyExpr(
                    start_ptr,
                    caster(
                        FieldFromPointer(target._C_field_data, target._C_symbol)
                    ) + Mul(target_time, sobjs['localsize']),
                    init=True
                ),
                petsc_call('VecPlaceArray', [xlocal, start_ptr])
            )
        return super().place_array(target)

    def reset_array(self, target):
        if self.is_target_time(target):
            sobjs = self.sobjs
            xlocal = sobjs.get(f'xlocal{target.name}', sobjs['xlocal'])
            return (
                petsc_call('VecResetArray', [xlocal])
            )
        return super().reset_array(target)

    def assign_time_iters(self, struct):
        """
        Assign required time iterators to the struct.
        These iterators are updated at each timestep in the main kernel
        for use in callback functions.
        Examples
        --------
        >>> struct
        ctx
        >>> struct.fields
        [h_x, x_M, x_m, f1(t, x), t0, t1]
        >>> assigned = assign_time_iters(struct)
        >>> print(assigned[0])
        ctx.t0 = t0;
        >>> print(assigned[1])
        ctx.t1 = t1;
        """
        to_assign = [
            f for f in struct.fields if (f.is_Dimension and (f.is_Time or f.is_Modulo))
        ]
        time_iter_assignments = [
            DummyExpr(FieldFromComposite(field, struct), field)
            for field in to_assign
        ]
        return time_iter_assignments
