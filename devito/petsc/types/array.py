from functools import cached_property
from ctypes import POINTER, Structure

from devito.types.utils import DimensionTuple
from devito.types.array import ArrayBasic, Bundle, ComponentAccess
from devito.finite_differences import Differentiable
from devito.types.basic import AbstractFunction, IndexedData
from devito.tools import dtype_to_ctype, as_tuple
from devito.symbolics import FieldFromComposite


class PETScArray(ArrayBasic, Differentiable):
    """
    PETScArrays are generated by the compiler only and represent
    a customised variant of ArrayBasic.
    Differentiable enables compatibility with standard Function objects,
    allowing for the use of the `subs` method.

    PETScArray objects represent vector objects within PETSc.
    They correspond to the spatial domain of a Function-like object
    provided by the user, which is passed to PETScSolve as the target.

    TODO: Potentially re-evaluate and separate into PETScFunction(Differentiable)
    and then PETScArray(ArrayBasic).
    """

    _data_alignment = False

    __rkwargs__ = (AbstractFunction.__rkwargs__ +
                   ('target', 'liveness', 'coefficients', 'localinfo'))

    def __init_finalize__(self, *args, **kwargs):

        self._target = kwargs.get('target')
        self._ndim = kwargs['ndim'] = len(self._target.space_dimensions)
        self._dimensions = kwargs['dimensions'] = self._target.space_dimensions
        super().__init_finalize__(*args, **kwargs)
        self._coefficients = self._target.coefficients
        self._localinfo = kwargs.get('localinfo', None)

    @property
    def ndim(self):
        return self._ndim

    @classmethod
    def __dtype_setup__(cls, **kwargs):
        return kwargs['target'].dtype

    @classmethod
    def __indices_setup__(cls, *args, **kwargs):
        target = kwargs['target']
        dimensions = tuple(target.indices[d] for d in target.space_dimensions)
        if args:
            indices = args
        else:
            indices = dimensions
        return as_tuple(dimensions), as_tuple(indices)

    def __halo_setup__(self, **kwargs):
        target = kwargs['target']
        halo = [target.halo[d] for d in target.space_dimensions]
        return DimensionTuple(*halo, getters=target.space_dimensions)

    @property
    def dimensions(self):
        return self._dimensions

    @property
    def target(self):
        return self._target

    @property
    def grid(self):
        return self.target.grid

    @property
    def coefficients(self):
        """Form of the coefficients of the function."""
        return self._coefficients

    @property
    def shape(self):
        return self.target.grid.shape

    @property
    def space_order(self):
        return self.target.space_order

    @property
    def staggered(self):
        return self.target.staggered

    @property
    def is_Staggered(self):
        return self.target.staggered is not None

    @property
    def localinfo(self):
        return self._localinfo

    @cached_property
    def _shape_with_inhalo(self):
        return self.target.shape_with_inhalo

    @cached_property
    def shape_allocated(self):
        return self.target.shape_allocated

    @cached_property
    def _C_ctype(self):
        return POINTER(dtype_to_ctype(self.dtype))

    @cached_property
    def _fd_priority(self):
        return self.target._fd_priority

    @property
    def symbolic_shape(self):
        field_from_composites = [
            FieldFromComposite('g%sm' % d.name, self.localinfo) for d in self.dimensions]
        # Reverse it since DMDA is setup backwards to Devito dimensions.
        return DimensionTuple(*field_from_composites[::-1], getters=self.dimensions)


class PetscBundle(Bundle):
    """
    """
    is_Bundle = True
    _data_alignment = False

    __rkwargs__ = Bundle.__rkwargs__ + ('pname',)

    def __init__(self, *args, pname="Field", **kwargs):
        super().__init__(*args, **kwargs)
        self._pname = pname

    @property
    def _C_ctype(self):
        fields = [(i.target.name, dtype_to_ctype(i.dtype)) for i in self.components]
        return POINTER(type(self.pname, (Structure,), {'_fields_': fields}))

    @cached_property
    def indexed(self):
        """The wrapped IndexedData object."""
        return AoSIndexedData(self.name, shape=self._shape, function=self.function)

    @cached_property
    def vector(self):
        return PETScArray(
            name=self.name,
            target=self.c0.target,
            liveness=self.c0.liveness,
            localinfo=self.c0.localinfo,
        )

    @property
    def _C_name(self):
        return self.vector._C_name

    def __getitem__(self, index):
        index = as_tuple(index)
        if len(index) == self.ndim:
            return super().__getitem__(index)
        elif len(index) == self.ndim + 1:
            component_index, indices = index[0], index[1:]
            names = tuple(i.target.name for i in self.components)
            return ComponentAccess(
                self.indexed[indices],
                component_index,
                component_names=names
            )
        else:
            raise ValueError("Expected %d or %d indices, got %d instead"
                             % (self.ndim, self.ndim + 1, len(index)))

    @property
    def pname(self):
        return self._pname


class AoSIndexedData(IndexedData):
    @property
    def dtype(self):
        return self.function._C_ctype
