from functools import cached_property
from ctypes import POINTER

from devito.types.utils import DimensionTuple
from devito.types.array import ArrayBasic
from devito.finite_differences import Differentiable
from devito.types.basic import AbstractFunction
from devito.finite_differences.tools import fd_weights_registry
from devito.tools import dtype_to_ctype, as_tuple
from devito.symbolics import FieldFromComposite


class PETScArray(ArrayBasic, Differentiable):
    """
    PETScArrays are generated by the compiler only and represent
    a customised variant of ArrayBasic.
    Differentiable enables compatibility with standard Function objects,
    allowing for the use of the `subs` method.

    PETScArray objects represent vector objects within PETSc.
    They correspond to the spatial domain of a Function-like object
    provided by the user, which is passed to PETScSolve as the target.

    TODO: Potentially re-evaluate and separate into PETScFunction(Differentiable)
    and then PETScArray(ArrayBasic).
    """

    _data_alignment = False

    # Default method for the finite difference approximation weights computation.
    _default_fd = 'taylor'

    __rkwargs__ = (AbstractFunction.__rkwargs__ +
                   ('target', 'liveness', 'coefficients', 'localinfo'))

    def __init_finalize__(self, *args, **kwargs):

        self._target = kwargs.get('target')
        self._ndim = kwargs['ndim'] = len(self._target.space_dimensions)
        self._dimensions = kwargs['dimensions'] = self._target.space_dimensions

        super().__init_finalize__(*args, **kwargs)

        # Symbolic (finite difference) coefficients
        self._coefficients = kwargs.get('coefficients', self._default_fd)
        if self._coefficients not in fd_weights_registry:
            raise ValueError("coefficients must be one of %s"
                             " not %s" % (str(fd_weights_registry), self._coefficients))

        self._localinfo = kwargs.get('localinfo', None)

    @property
    def ndim(self):
        return self._ndim

    @classmethod
    def __dtype_setup__(cls, **kwargs):
        return kwargs['target'].dtype

    @classmethod
    def __indices_setup__(cls, *args, **kwargs):
        target = kwargs['target']
        dimensions = tuple(target.indices[d] for d in target.space_dimensions)
        if args:
            indices = args
        else:
            indices = dimensions
        return as_tuple(dimensions), as_tuple(indices)

    def __halo_setup__(self, **kwargs):
        target = kwargs['target']
        halo = [target.halo[d] for d in target.space_dimensions]
        return DimensionTuple(*halo, getters=target.space_dimensions)

    @property
    def dimensions(self):
        return self._dimensions

    @property
    def target(self):
        return self._target

    @property
    def coefficients(self):
        """Form of the coefficients of the function."""
        return self._coefficients

    @property
    def shape(self):
        return self.target.grid.shape

    @property
    def space_order(self):
        return self.target.space_order

    @property
    def is_Staggered(self):
        return self.target.staggered is not None

    @property
    def localinfo(self):
        return self._localinfo

    @cached_property
    def _shape_with_inhalo(self):
        return self.target.shape_with_inhalo

    @cached_property
    def shape_allocated(self):
        return self.target.shape_allocated

    @cached_property
    def _C_ctype(self):
        return POINTER(dtype_to_ctype(self.dtype))

    @property
    def symbolic_shape(self):
        field_from_composites = [
            FieldFromComposite('g%sm' % d.name, self.localinfo) for d in self.dimensions]
        # Reverse it since DMDA is setup backwards to Devito dimensions.
        return DimensionTuple(*field_from_composites[::-1], getters=self.dimensions)
